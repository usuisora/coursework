{"version":3,"sources":["../src/extend.js"],"names":["indent","extend","INDENT","$$hints","Symbol","text","replace","base","extra","hint","hints","keysB","Object","keys","extraHints","key","newValue","hintB","hintA","firstEntityDetails","chalk","magenta","secondEntityDetails","yellow","Error","bold","assign"],"mappings":";;;;;QAMgBA,M,GAAAA,M;kBAMQC,M;;AAXxB;;;;;;AAEA,MAAMC,SAAS,IAAf;;AACA,MAAMC,UAAUC,OAAO,OAAP,CAAhB;;AAEO,SAASJ,MAAT,CAAgBK,IAAhB,EAA8B;AACnC,SACEH,SAASG,KAAKC,OAAL,CAAa,KAAb,EAAoB,OAAOJ,MAA3B,EAAmCI,OAAnC,CAA2C,eAA3C,EAA4D,IAA5D,CADX;AAGD;;AAEc,SAASL,MAAT,CACbM,IADa,EAEbC,KAFa,EAGbC,IAHa,EAIA;AACb;AACA,QAAMC,QAAQH,KAAKJ,OAAL,KAAiB,EAA/B;;AAEA,QAAMQ,QAAQC,OAAOC,IAAP,CAAYL,KAAZ,CAAd;AACA,QAAMM,aAAaN,MAAML,OAAN,KAAkB,EAArC;AACA,OAAK,MAAMY,GAAX,IAAkBJ,KAAlB,EAAyB;AACvB,UAAMK,WAAWR,MAAMO,GAAN,CAAjB;AACA,UAAME,QAAQH,WAAWC,GAAX,KAAmBN,IAAjC;AACA,QAAIM,OAAOR,IAAP,IAAeA,KAAKQ,GAAL,MAAcC,QAAjC,EAA2C;AACzC;AACA,YAAME,QAAiBR,MAAMK,GAAN,CAAvB;AACA,YAAMI,qBAAqB,CAACD,KAAD,GACvB,uDADuB,GAEtB,4BAA2BlB,OAAOoB,gBAAMC,OAAN,CAAcH,KAAd,CAAP,CAA6B,EAF7D;AAGA,YAAMI,sBAAsB,CAACL,KAAD,GACxB,wDADwB,GAEvB,6BAA4BjB,OAAOoB,gBAAMG,MAAN,CAAaN,KAAb,CAAP,CAA4B,EAF7D;AAGA,YAAM,IAAIO,KAAJ,CACH,oFAAmFJ,gBAAMK,IAAN,CAClFV,GADkF,CAElF,SAAQf,OAAOmB,kBAAP,CAA2B,OAAMnB,OAAOsB,mBAAP,CAA4B,EAHnE,CAAN;AAKD;AACD,QAAIL,KAAJ,EAAW;AACTP,YAAMK,GAAN,IAAaE,KAAb;AACD;AACF;AACD,SAAOL,OAAOc,MAAP,CAAcnB,IAAd,EAAoBC,KAApB,EAA2B;AAChC;AACA,KAACL,OAAD,GAAWO;AAFqB,GAA3B,CAAP;AAID","file":"extend.js","sourcesContent":["// @flow\nimport chalk from \"chalk\";\n\nconst INDENT = \"  \";\nconst $$hints = Symbol(\"hints\");\n\nexport function indent(text: string) {\n  return (\n    INDENT + text.replace(/\\n/g, \"\\n\" + INDENT).replace(/\\n +(?=\\n|$)/g, \"\\n\")\n  );\n}\n\nexport default function extend<Obj1: *, Obj2: *>(\n  base: Obj1,\n  extra: Obj2,\n  hint?: string\n): Obj1 & Obj2 {\n  // $FlowFixMe\n  const hints = base[$$hints] || {};\n\n  const keysB = Object.keys(extra);\n  const extraHints = extra[$$hints] || {};\n  for (const key of keysB) {\n    const newValue = extra[key];\n    const hintB = extraHints[key] || hint;\n    if (key in base && base[key] !== newValue) {\n      // $FlowFixMe\n      const hintA: ?string = hints[key];\n      const firstEntityDetails = !hintA\n        ? \"We don't have any information about the first entity.\"\n        : `The first entity was:\\n\\n${indent(chalk.magenta(hintA))}`;\n      const secondEntityDetails = !hintB\n        ? \"We don't have any information about the second entity.\"\n        : `The second entity was:\\n\\n${indent(chalk.yellow(hintB))}`;\n      throw new Error(\n        `A naming conflict has occurred - two entities have tried to define the same key '${chalk.bold(\n          key\n        )}'.\\n\\n${indent(firstEntityDetails)}\\n\\n${indent(secondEntityDetails)}`\n      );\n    }\n    if (hintB) {\n      hints[key] = hintB;\n    }\n  }\n  return Object.assign(base, extra, {\n    // $FlowFixMe\n    [$$hints]: hints,\n  });\n}\n"]}