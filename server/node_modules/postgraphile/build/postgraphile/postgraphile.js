"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pg_1 = require("pg");
const pg_connection_string_1 = require("pg-connection-string");
const events_1 = require("events");
const postgraphile_core_1 = require("postgraphile-core");
const createPostGraphileHttpRequestHandler_1 = require("./http/createPostGraphileHttpRequestHandler");
const exportPostGraphileSchema_1 = require("./schema/exportPostGraphileSchema");
const pluginHook_1 = require("./pluginHook");
const chalk = require("chalk");
/**
 * Creates a PostGraphile Http request handler by first introspecting the
 * database to get a GraphQL schema, and then using that to create the Http
 * request handler.
 */
function getPostgraphileSchemaBuilder(pgPool, schema, incomingOptions) {
    const pluginHook = pluginHook_1.pluginHookFromOptions(incomingOptions);
    const options = pluginHook('postgraphile:options', incomingOptions, {
        pgPool,
        schema,
    });
    // Check for a jwtSecret without a jwtPgTypeIdentifier
    // a secret without a token identifier prevents JWT creation
    if (options.jwtSecret && !options.jwtPgTypeIdentifier) {
        // tslint:disable-next-line no-console
        console.warn('WARNING: jwtSecret provided, however jwtPgTypeIdentifier (token identifier) not provided.');
    }
    if (options.handleErrors && (options.extendedErrors || options.showErrorStack)) {
        throw new Error(`You cannot combine 'handleErrors' with the other error options`);
    }
    // Creates the Postgres schemas array.
    const pgSchemas = Array.isArray(schema) ? schema : [schema];
    const _emitter = new events_1.EventEmitter();
    // Creates a promise which will resolve to a GraphQL schema. Connects a
    // client from our pool to introspect the database.
    //
    // This is not a constant because when we are in watch mode, we want to swap
    // out the `gqlSchema`.
    let gqlSchema;
    const gqlSchemaPromise = createGqlSchema();
    return {
        _emitter,
        getGraphQLSchema: () => Promise.resolve(gqlSchema || gqlSchemaPromise),
        options,
    };
    async function createGqlSchema() {
        try {
            if (options.watchPg) {
                await postgraphile_core_1.watchPostGraphileSchema(pgPool, pgSchemas, options, newSchema => {
                    gqlSchema = newSchema;
                    _emitter.emit('schemas:changed');
                    exportGqlSchema(gqlSchema);
                });
                if (!gqlSchema) {
                    throw new Error("Consistency error: watchPostGraphileSchema promises to call the callback before the promise resolves; but this hasn't happened");
                }
            }
            else {
                gqlSchema = await postgraphile_core_1.createPostGraphileSchema(pgPool, pgSchemas, options);
                exportGqlSchema(gqlSchema);
            }
            return gqlSchema;
        }
        catch (error) {
            // If we fail to build our schema, log the error and exit the process.
            return handleFatalError(error, 'building the initial schema');
        }
    }
    async function exportGqlSchema(newGqlSchema) {
        try {
            await exportPostGraphileSchema_1.default(newGqlSchema, options);
        }
        catch (error) {
            // If we fail to export our schema, log the error and exit the process.
            handleFatalError(error, 'exporting the schema');
        }
    }
}
exports.getPostgraphileSchemaBuilder = getPostgraphileSchemaBuilder;
function postgraphile(poolOrConfig, schemaOrOptions, maybeOptions) {
    let schema;
    // These are the raw options we're passed in; getPostgraphileSchemaBuilder
    // must process them with `pluginHook` before we can rely on them.
    let incomingOptions;
    // If the second argument is a string or array, it is the schemas so set the
    // `schema` value and try to use the third argument (or a default) for
    // `incomingOptions`.
    if (typeof schemaOrOptions === 'string' || Array.isArray(schemaOrOptions)) {
        schema = schemaOrOptions;
        incomingOptions = maybeOptions || {};
    }
    // If the second argument is null or an object then use default `schema`
    // and set incomingOptions to second or third argument (or default).
    else if (typeof schemaOrOptions === 'object') {
        schema = 'public';
        incomingOptions = schemaOrOptions || maybeOptions || {};
    }
    // Otherwise if the second argument is present it's invalid: throw an error.
    else if (arguments.length > 1) {
        throw new Error('The second argument to postgraphile was invalid... did you mean to set a schema?');
    }
    // No schema or options specified, use defaults.
    else {
        schema = 'public';
        incomingOptions = {};
    }
    if (typeof poolOrConfig === 'undefined' && arguments.length >= 1) {
        throw new Error('The first argument to postgraphile was `undefined`... did you mean to set pool options?');
    }
    // Do some things with `poolOrConfig` so that in the end, we actually get a
    // Postgres pool.
    const pgPool = toPgPool(poolOrConfig);
    pgPool.on('error', err => {
        /*
         * This handler is required so that client connection errors don't bring
         * the server down (via `unhandledError`).
         *
         * `pg` will automatically terminate the client and remove it from the
         * pool, so we don't actually need to take any action here, just ensure
         * that the event listener is registered.
         */
        // tslint:disable-next-line no-console
        console.error('PostgreSQL client generated error: ', err);
    });
    const { getGraphQLSchema, options, _emitter } = getPostgraphileSchemaBuilder(pgPool, schema, incomingOptions);
    return createPostGraphileHttpRequestHandler_1.default(Object.assign({}, options, { getGqlSchema: getGraphQLSchema, pgPool,
        _emitter }));
}
exports.default = postgraphile;
function handleFatalError(error, when) {
    process.stderr.write(`A fatal error occurred when ${chalk.bold(when)}, so the process will now exit. Error details:\n\n`);
    process.stderr.write(`${error.stack}\n`); // console.error fails under the tests
    process.exit(1);
    // `process.exit` will mean all code below it will never get called.
    // However, we need to return a value with type `never` here for
    // TypeScript.
    return null;
}
function constructorName(obj) {
    return ((obj &&
        typeof obj.constructor === 'function' &&
        obj.constructor.name &&
        String(obj.constructor.name)) ||
        null);
}
// tslint:disable-next-line no-any
function toPgPool(poolOrConfig) {
    if (quacksLikePgPool(poolOrConfig)) {
        // If it is already a `Pool`, just use it.
        return poolOrConfig;
    }
    return new pg_1.Pool(typeof poolOrConfig === 'string'
        ? // Otherwise if it is a string, let us parse it to get a config to
            // create a `Pool`.
            pg_connection_string_1.parse(poolOrConfig)
        : // Finally, it must just be a config itself. If it is undefined, we
            // will just use an empty config and let the defaults take over.
            poolOrConfig || {});
}
// tslint:disable-next-line no-any
function quacksLikePgPool(pgConfig) {
    if (pgConfig instanceof pg_1.Pool)
        return true;
    // A diagnosis of exclusion
    if (!pgConfig || typeof pgConfig !== 'object')
        return false;
    if (constructorName(pgConfig) !== 'Pool' && constructorName(pgConfig) !== 'BoundPool')
        return false;
    if (!pgConfig['Client'])
        return false;
    if (!pgConfig['options'])
        return false;
    if (typeof pgConfig['connect'] !== 'function')
        return false;
    if (typeof pgConfig['end'] !== 'function')
        return false;
    if (typeof pgConfig['query'] !== 'function')
        return false;
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zdGdyYXBoaWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Bvc3RncmFwaGlsZS9wb3N0Z3JhcGhpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQkFBc0M7QUFDdEMsK0RBQXdFO0FBRXhFLG1DQUFzQztBQUN0Qyx5REFBc0Y7QUFDdEYsc0dBQStGO0FBQy9GLGdGQUF5RTtBQUN6RSw2Q0FBcUQ7QUFFckQsK0JBQWdDO0FBUWhDOzs7O0dBSUc7QUFDSCxzQ0FDRSxNQUFZLEVBQ1osTUFBOEIsRUFDOUIsZUFBb0M7SUFFcEMsTUFBTSxVQUFVLEdBQUcsa0NBQXFCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDMUQsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLHNCQUFzQixFQUFFLGVBQWUsRUFBRTtRQUNsRSxNQUFNO1FBQ04sTUFBTTtLQUNQLENBQUMsQ0FBQztJQUNILHNEQUFzRDtJQUN0RCw0REFBNEQ7SUFDNUQsSUFBSSxPQUFPLENBQUMsU0FBUyxJQUFJLENBQUMsT0FBTyxDQUFDLG1CQUFtQixFQUFFO1FBQ3JELHNDQUFzQztRQUN0QyxPQUFPLENBQUMsSUFBSSxDQUNWLDJGQUEyRixDQUM1RixDQUFDO0tBQ0g7SUFFRCxJQUFJLE9BQU8sQ0FBQyxZQUFZLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsRUFBRTtRQUM5RSxNQUFNLElBQUksS0FBSyxDQUFDLGdFQUFnRSxDQUFDLENBQUM7S0FDbkY7SUFFRCxzQ0FBc0M7SUFDdEMsTUFBTSxTQUFTLEdBQWtCLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUUzRSxNQUFNLFFBQVEsR0FBRyxJQUFJLHFCQUFZLEVBQUUsQ0FBQztJQUVwQyx1RUFBdUU7SUFDdkUsbURBQW1EO0lBQ25ELEVBQUU7SUFD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