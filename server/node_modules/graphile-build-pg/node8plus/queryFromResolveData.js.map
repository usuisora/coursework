{"version":3,"sources":["../src/queryFromResolveData.js"],"names":["sql","identity","_","undefined","from","fromAlias","resolveData","options","withBuilder","pgQuery","pgCursorPrefix","reallyRawCursorPrefix","pgCalculateTotalCount","calculateHasNextPage","calculateHasPreviousPage","usesCursor","explicitlyUsesCursor","length","rawCursorPrefix","filter","queryBuilder","QueryBuilder","queryBuilderOptions","fn","generateNextPrevPageSql","sqlQueryAlias","canHaveCursorInWhere","queryHasBefore","queryHasFirst","offset","invert","sqlCommonUnbounded","fragment","getTableExpression","getTableAlias","sqlCommon","buildWhereClause","isForwardOrSymmetric","literal","buildWhereBoundClause","getSelectCursor","blank","value","limit","getFinalLimitAndOffset","getPgCursorPrefix","data","cursorPrefix","map","val","withPagination","withPaginationAsFields","withCursor","selectCursor","orderBy","getOrderByExpressionsAndDirections","expr","isOrderUnique","join","setCursorComparator","cursorValue","isAfter","orderByExpressionsAndDirections","sqlCursors","Array","isArray","whereBound","sqlFilter","i","sqlExpression","ascending","comparison","Number","sqlOldFilter","null","getOffset","Math","max","Error","query","build","haveFields","getSelectFieldsCount","identifier","Symbol","sqlSummaryAlias","compiledData","upper","queryHasAfter","lower","queryHasZeroLimit","getFinalLimit","first","queryHasLast","last","hasNextPage","getFinalOffset","hasPreviousPage","totalCount","sqlWith","sqlFrom","fields","push","alias","jsonbBuildObject"],"mappings":"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","file":"queryFromResolveData.js","sourcesContent":["// @flow\nimport QueryBuilder from \"./QueryBuilder\";\nimport type QueryBuilderOptions from \"./QueryBuilder\";\nimport type { RawAlias } from \"./QueryBuilder\";\nimport * as sql from \"pg-sql2\";\nimport type { SQL } from \"pg-sql2\";\nimport type { DataForType } from \"graphile-build\";\nimport isSafeInteger from \"lodash/isSafeInteger\";\nimport assert from \"assert\";\n\nconst identity = _ => _ !== null && _ !== undefined;\n\nexport default (\n  from: SQL,\n  fromAlias: ?SQL,\n  resolveData: DataForType,\n  options: {\n    withPagination?: boolean,\n    withPaginationAsFields?: boolean,\n    asJson?: boolean,\n    asJsonAggregate?: boolean,\n    addNullCase?: boolean,\n    onlyJsonField?: boolean,\n    queryBuilderOptions?: QueryBuilderOptions,\n  },\n  withBuilder?: (builder: QueryBuilder) => void\n) => {\n  const {\n    pgQuery,\n    pgCursorPrefix: reallyRawCursorPrefix,\n    pgCalculateTotalCount,\n    calculateHasNextPage,\n    calculateHasPreviousPage,\n    usesCursor: explicitlyUsesCursor,\n  } = resolveData;\n\n  const usesCursor: boolean =\n    (explicitlyUsesCursor && explicitlyUsesCursor.length > 0) ||\n    (calculateHasNextPage && calculateHasNextPage.length > 0) ||\n    (calculateHasPreviousPage && calculateHasPreviousPage.length > 0) ||\n    false;\n  const rawCursorPrefix =\n    reallyRawCursorPrefix && reallyRawCursorPrefix.filter(identity);\n\n  const queryBuilder = new QueryBuilder(options.queryBuilderOptions);\n  queryBuilder.from(from, fromAlias ? fromAlias : undefined);\n\n  if (withBuilder) {\n    withBuilder(queryBuilder);\n  }\n  for (const fn of pgQuery || []) {\n    fn(queryBuilder, resolveData);\n  }\n\n  function generateNextPrevPageSql(\n    sqlQueryAlias,\n    canHaveCursorInWhere,\n    queryHasBefore,\n    queryHasFirst,\n    offset = 0,\n    invert = false\n  ) {\n    /*\n     * Strap in, 'coz this function gets hairy!\n     *\n     * The point of this function is to return SQL which will resolve to a\n     * boolean true/false depending on whether or not there is a (invert ?\n     * \"previous\" : \"next\") page.\n     *\n     * Connections have before, after, first, last and offset.\n     * - Users are forbidden from setting both first and last.\n     * - Users are forbidden from setting both offset and last.\n     *\n     * Further there are two main modes of paginating, one works by adding a\n     * where clause (this is preferred, but is not always possible, and is\n     * indicated by `canHaveCursorInWhere === true`) and the other works using\n     * standard LIMIT/OFFSET SQL pagination (and is indicated by\n     * `canHaveCursorInWhere === false`).\n     *\n     * The following diagram shows a full collection of records, #, starting at\n     * START and ending at END. The key after, before, offset, first and last\n     * variables are shown. One thing not show is that it's possible to have\n     * fewer records between before and after than requested by first or last.\n     * Another detail not clearly show is that if there is no `after` then\n     * `START` is used, similarly if there is no `before` then `END` is used.\n     *\n     *   #################################################### < collection\n     *   ^      ^<-offset->^<-first->^      ^<-last->^      ^\n     *   |      |          |         |      |        |      |\n     *   |      |          +---------+      +--------+      |\n     *   |      |          |  DATA1           DATA2  |      |\n     *   |      |          |                         |      |\n     *   |      |          |                         |      |\n     *   |      |          +-------------------------+      |\n     *   |      |                     DATA3          |      |\n     *   |    after                                before   |\n     *   |                                                  |\n     * START                                               END\n     *\n     * We want one of the three DATA blocks:\n     *\n     * - If `first` is set, then we want DATA1.\n     * - If `last` is set then we want DATA2.\n     * - If neither is set then we want DATA3.\n     *\n     * (Remember: you cannot set both `first` and `last` at the same time.)\n     *\n     * When invert === false:\n     *\n     *   Note that both DATA2 and DATA3 end at the same point, and we only care\n     *   if there's data *after* the relevant DATA block, so really we only\n     *   care if the query specified `first` (`queryHasFirst`) which makes\n     *   things complex (ending at the end of DATA1), otherwise we can use\n     *   `before` as the bound (end of DATA2/DATA3).\n     *\n     * When invert === true:\n     *\n     *   Similarly, DATA1 and DATA3 start at the same point, and we're going\n     *   backwards so we only care if there's data *before* the DATA block, so\n     *   really we just need to know if the query set `last` or not, but since\n     *   this is inverted we call it `queryHasFirst`.\n     *\n     * When `invert` is false we're calculating `hasNextPage`, when true we're\n     * calculating `hasPreviousPage`.\n     *\n     * Because of the near-symmetry of requesting hasPreviousPage vs\n     * hasNextPage we always pretend we're determining `hasNextPage`, and we\n     * just invert everything.\n     */\n\n    const sqlCommonUnbounded = sql.fragment`\n      select 1\n      from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n      `;\n    /*\n     * This variable is a fragment to go into an `EXISTS(...)` call (after some tweaks).\n     *\n     * The buildWhereClause takes three arguments:\n     *\n     * - includeLowerBound (we want this for hasNextPage but not hasPreviousPage)\n     * - includeUpperBound (we want this for hasPreviousPage but not hasNextPage)\n     * - options (specifically `{addNullCase}`) - we just pass this through.\n     *\n     * So in hasNextPage mode (invert === false), this common SQL ends up\n     * representing the collection from `(after || START)` onwards with no\n     * upper bound. In hasPreviousPage mode (invert === true), it represents\n     * everything from `(before || END)` backwards, with no lower bound.\n     */\n    const sqlCommon = sql.fragment`\n      ${sqlCommonUnbounded}\n      where ${queryBuilder.buildWhereClause(!invert, invert, options)}\n    `;\n\n    /*\n     * Since the offset makes the diagram asymmetric, if offset === 0\n     * then the diagram is symmetric and things are simplified a little.\n     */\n    const isForwardOrSymmetric = !invert || offset === 0;\n\n    if (!isForwardOrSymmetric) {\n      assert(invert);\n      assert(offset > 0);\n      // We're looking for a previous page, and there's an offset, so lets just\n      // assume there's a previous page where offset is smaller.\n      return sql.literal(true);\n    } else if (canHaveCursorInWhere) {\n      assert(isForwardOrSymmetric);\n      if (!queryHasBefore && !queryHasFirst) {\n        assert(isForwardOrSymmetric);\n        // There can be no next page since there's no upper bound\n        return sql.literal(false);\n      } else if (queryHasBefore && !queryHasFirst) {\n        /*\n         * We invert the upper buildWhereBoundClause to only represent the data\n         * after `before`, then check if there's at least one record in that set.\n         *\n         * This only works if the `before` cursor can be represented in the\n         * SQL WHERE clause, otherwise we're doing limit/offset pagination\n         * which requires different logic. It also only works if there's no\n         * `first` clause, otherwise there could be a next page before the\n         * `before` clause.\n         */\n        return sql.fragment`exists(\n          ${sqlCommonUnbounded}\n          where ${queryBuilder.buildWhereClause(false, false, options)}\n          and not (${queryBuilder.buildWhereBoundClause(invert)})\n        )`;\n      } else {\n        assert(queryHasFirst);\n        // queryHasBefore could be true or false.\n        /*\n         * There's a few ways that we could determine if there's a next page.\n         *\n         * If !queryHasBefore, we could COUNT(*) the number of rows in\n         * `sqlCommon` and see if it's larger than `first`:\n         * `(select count(*) > ${first} from (${sqlCommon}) __random_table_alias__)`\n         *\n         * If !queryHasBefore, we could build a subquery table of offsetData\n         * from sqlCommon and see if it contains any rows:\n         * `EXISTS(select 1 from (${sqlCommon} OFFSET ${first}) __random_table_alias__)`.\n         *\n         * We could see if there's at least one row in sqlCommon that's not\n         * already in our chosen result set.\n         *\n         * We've chosen the latter approach here because it doesn't place a limit\n         * on queryHasBefore.\n         */\n        // Drop the `first` limit, see if there are any records that aren't\n        // already in the list we've fetched.\n        return sql.fragment`exists(\n          ${sqlCommon}\n          and (${queryBuilder.getSelectCursor()})::text not in (select __cursor::text from ${sqlQueryAlias})\n          ${\n            offset === 0 ? sql.blank : sql.fragment`offset ${sql.value(offset)}`\n          }\n        )`;\n      }\n    } else {\n      assert(!invert || offset === 0); // isForwardOrSymmetric\n      assert(!canHaveCursorInWhere);\n      // We're dealing with LIMIT/OFFSET pagination here, which means `natural`\n      // cursors, so the `queryBuilder` factors the before/after, first/last\n      // into the limit / offset.\n      const { limit } = queryBuilder.getFinalLimitAndOffset();\n\n      if (limit == null) {\n        // If paginating backwards, then offset > 0 has already been dealt\n        // with. Unbounded, so there's no next page.\n        return sql.fragment`false`;\n      } else if (invert) {\n        assert(offset === 0);\n        // Paginating backwards and there's no offset (which factors in before/after), so there's no previous page.\n        return sql.fragment`false`;\n      } else {\n        assert(!invert);\n        /*\n         * We're paginating forwards; either there's a before, there's a first,\n         * or both.\n         *\n         * We want to see if there's more than limit+offset records in sqlCommon.\n         */\n        return sql.fragment`exists(\n          ${sqlCommon}\n          offset ${sql.literal(limit + offset)}\n        )`;\n      }\n    }\n  }\n  const getPgCursorPrefix = () =>\n    rawCursorPrefix && rawCursorPrefix.length > 0\n      ? rawCursorPrefix\n      : queryBuilder.data.cursorPrefix.map(val => sql.literal(val));\n  if (\n    options.withPagination ||\n    options.withPaginationAsFields ||\n    options.withCursor\n  ) {\n    // Sometimes we need a __cursor even if it's not a collection; e.g. to get the edge field on a mutation\n    if (usesCursor) {\n      queryBuilder.selectCursor(() => {\n        const orderBy = queryBuilder\n          .getOrderByExpressionsAndDirections()\n          .map(([expr]) => expr);\n        if (queryBuilder.isOrderUnique() && orderBy.length > 0) {\n          return sql.fragment`json_build_array(${sql.join(\n            [\n              ...getPgCursorPrefix(),\n              sql.fragment`json_build_array(${sql.join(orderBy, \", \")})`,\n            ],\n            \", \"\n          )})`;\n        } else {\n          return sql.fragment`json_build_array(${sql.join(\n            getPgCursorPrefix(),\n            \", \"\n          )}, (row_number() over (partition by 1)))`;\n        }\n      });\n    }\n  }\n  if (options.withPagination || options.withPaginationAsFields) {\n    queryBuilder.setCursorComparator((cursorValue, isAfter) => {\n      const orderByExpressionsAndDirections = queryBuilder.getOrderByExpressionsAndDirections();\n      if (\n        orderByExpressionsAndDirections.length > 0 &&\n        queryBuilder.isOrderUnique()\n      ) {\n        const sqlCursors = cursorValue[getPgCursorPrefix().length].map(val =>\n          sql.value(val)\n        );\n        if (!Array.isArray(sqlCursors)) {\n          queryBuilder.whereBound(sql.literal(false), isAfter);\n        }\n        let sqlFilter = sql.fragment`false`;\n        for (let i = orderByExpressionsAndDirections.length - 1; i >= 0; i--) {\n          const [sqlExpression, ascending] = orderByExpressionsAndDirections[i];\n          // If ascending and isAfter then >\n          // If ascending and isBefore then <\n          const comparison =\n            Number(ascending) ^ Number(!isAfter)\n              ? sql.fragment`>`\n              : sql.fragment`<`;\n\n          const sqlOldFilter = sqlFilter;\n          sqlFilter = sql.fragment`\n          (\n            (\n              ${sqlExpression} ${comparison} ${sqlCursors[i] || sql.null}\n            )\n          OR\n            (\n              (\n                ${sqlExpression} = ${sqlCursors[i] || sql.null}\n              AND\n                ${sqlOldFilter}\n              )\n            )\n          )\n          `;\n        }\n        queryBuilder.whereBound(sqlFilter, isAfter);\n      } else if (\n        cursorValue[0] === \"natural\" &&\n        isSafeInteger(cursorValue[1]) &&\n        cursorValue[1] >= 0\n      ) {\n        if (isAfter) {\n          queryBuilder.offset(() => cursorValue[1]);\n        } else {\n          queryBuilder.limit(() => {\n            const offset = queryBuilder.getOffset();\n            return Math.max(0, cursorValue[1] - offset - 1);\n          });\n        }\n      } else {\n        throw new Error(\"Cannot use cursors without orderBy\");\n      }\n    });\n\n    const query = queryBuilder.build(options);\n    const haveFields = queryBuilder.getSelectFieldsCount() > 0;\n    const sqlQueryAlias = sql.identifier(Symbol());\n    const sqlSummaryAlias = sql.identifier(Symbol());\n    //\n    // Tables should ALWAYS push their PK onto the order stack, if this isn't\n    // present then we're either dealing with a view or a table without a PK.\n    // Either way, we don't have anything to guarantee uniqueness so we need to\n    // fall back to limit/offset.\n    //\n    // TODO: support unique keys in PgAllRows etc\n    // TODO: add a warning for cursor-based pagination when using the fallback\n    // TODO: if it is a view maybe add a warning encouraging pgViewUniqueKey\n    const canHaveCursorInWhere =\n      queryBuilder.getOrderByExpressionsAndDirections().length > 0 &&\n      queryBuilder.isOrderUnique();\n    const queryHasBefore =\n      queryBuilder.compiledData.whereBound.upper.length > 0;\n    const queryHasAfter = queryBuilder.compiledData.whereBound.lower.length > 0;\n    const queryHasZeroLimit = queryBuilder.getFinalLimit() === 0;\n    const queryHasFirst = isSafeInteger(queryBuilder.compiledData.first);\n    const queryHasLast = isSafeInteger(queryBuilder.compiledData.last);\n    const hasNextPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasBefore,\n          queryHasFirst,\n          queryBuilder.getFinalOffset() || 0\n        );\n    const hasPreviousPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasAfter,\n          queryHasLast,\n          queryBuilder.getFinalOffset() || 0,\n          true\n        );\n\n    const totalCount = sql.fragment`(\n      select count(*)\n      from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n      where ${queryBuilder.buildWhereClause(false, false, options)}\n    )`;\n    const sqlWith = haveFields\n      ? sql.fragment`with ${sqlQueryAlias} as (${query}), ${sqlSummaryAlias} as (select json_agg(to_json(${sqlQueryAlias})) as data from ${sqlQueryAlias})`\n      : sql.fragment``;\n    const sqlFrom = sql.fragment``;\n    const fields: Array<[SQL, RawAlias]> = [];\n    if (haveFields) {\n      fields.push([\n        sql.fragment`coalesce((select ${sqlSummaryAlias}.data from ${sqlSummaryAlias}), '[]'::json)`,\n        \"data\",\n      ]);\n      if (calculateHasNextPage) {\n        fields.push([hasNextPage, \"hasNextPage\"]);\n      }\n      if (calculateHasPreviousPage) {\n        fields.push([hasPreviousPage, \"hasPreviousPage\"]);\n      }\n    }\n    if (pgCalculateTotalCount) {\n      fields.push([totalCount, \"totalCount\"]);\n    }\n    if (options.withPaginationAsFields) {\n      return sql.fragment`${sqlWith} select ${sql.join(\n        fields.map(\n          ([expr, alias]) => sql.fragment`${expr} as ${sql.identifier(alias)}`\n        ),\n        \", \"\n      )} ${sqlFrom}`;\n    } else {\n      return sql.fragment`${sqlWith} select ${QueryBuilder.jsonbBuildObject(\n        fields\n      )} ${sqlFrom}`;\n    }\n  } else {\n    const query = queryBuilder.build(options);\n    return query;\n  }\n};\n"]}