"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.quacksLikePgPool = quacksLikePgPool;

var _pg = require("pg");

var _pg2 = _interopRequireDefault(_pg);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("graphile-build-pg");

function constructorName(obj) {
  return obj && typeof obj.constructor === "function" && obj.constructor.name;
}

// Some duck-typing

function quacksLikePgClient(pgConfig) {
  // A diagnosis of exclusion
  if (!pgConfig || typeof pgConfig !== "object") return false;
  if (constructorName(pgConfig) !== "Client") return false;
  if (typeof pgConfig.connect !== "function") return false;
  if (typeof pgConfig.end !== "function") return false;
  if (typeof pgConfig.escapeLiteral !== "function") return false;
  if (typeof pgConfig.escapeIdentifier !== "function") return false;
  return true;
}

function quacksLikePgPool(pgConfig) {
  // A diagnosis of exclusion
  if (!pgConfig || typeof pgConfig !== "object") return false;
  if (constructorName(pgConfig) !== "Pool" && constructorName(pgConfig) !== "BoundPool") {
    return false;
  }
  if (!pgConfig.Client) return false;
  if (!pgConfig.options) return false;
  if (typeof pgConfig.connect !== "function") return false;
  if (typeof pgConfig.end !== "function") return false;
  if (typeof pgConfig.query !== "function") return false;
  return true;
}

const withPgClient = async (pgConfig = process.env.DATABASE_URL, fn) => {
  if (!fn) {
    throw new Error("Nothing to do!");
  }
  let releasePgClient = () => {};
  let pgClient;
  let result;
  try {
    if (pgConfig instanceof _pg2.default.Client || quacksLikePgClient(pgConfig)) {
      pgClient = pgConfig;
      if (!pgClient.release) {
        throw new Error("We only support PG clients from a PG pool (because otherwise the `await` call can hang indefinitely if an error occurs and there's no error handler)");
      }
    } else if (pgConfig instanceof _pg2.default.Pool || quacksLikePgPool(pgConfig)) {
      const pgPool = pgConfig;
      pgClient = await pgPool.connect();
      releasePgClient = () => pgClient.release();
    } else if (pgConfig === undefined || typeof pgConfig === "string") {
      pgClient = new _pg2.default.Client(pgConfig);
      pgClient.on("error", e => {
        debug("pgClient error occurred: %s", e);
      });
      releasePgClient = () => new Promise((resolve, reject) => pgClient.end(err => err ? reject(err) : resolve()));
      await new Promise((resolve, reject) => pgClient.connect(err => err ? reject(err) : resolve()));
    } else {
      throw new Error("You must provide either a pg.Pool or pg.Client instance or a PostgreSQL connection string.");
    }
    result = await fn(pgClient);
  } finally {
    try {
      await releasePgClient();
    } catch (e) {
      // Failed to release, assuming success
    }
  }
  return result;
};

exports.default = withPgClient;
//# sourceMappingURL=withPgClient.js.map