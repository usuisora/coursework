{"version":3,"sources":["../../src/plugins/PgBackwardRelationPlugin.js"],"names":["debug","OMIT","DEPRECATED","ONLY","PgBackwardRelationPlugin","builder","pgLegacyRelations","pgSimpleCollections","hasConnections","hasSimpleCollections","legacyRelationMode","only","deprecated","hook","fields","build","context","extend","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","graphql","GraphQLNonNull","GraphQLList","inflection","pgQueryFromResolveData","queryFromResolveData","pgAddStartEndCursor","addStartEndCursor","pgOmit","omit","sqlCommentByAddingTags","describePgEntity","scope","isPgRowType","pgIntrospection","foreignTable","fieldWithHooks","Self","kind","foreignKeyConstraints","foreignConstraints","filter","con","type","foreignTableTypeName","tableType","gqlForeignTableType","id","reduce","memo","constraint","table","classById","classId","tableTypeName","gqlTableType","Error","name","schema","namespace","keys","keyAttributes","foreignKeys","foreignKeyAttributes","every","_","some","key","isUnique","constraints","find","c","keyAttributeNums","length","n","i","num","isDeprecated","singleRelationFieldName","singleRelationByKeysBackwards","primaryKeyConstraint","primaryKeys","shouldAddSingleRelation","shouldAddManyRelation","getDataFromParsedResolveInfoFragment","addDataGenerator","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","tableAlias","identifier","Symbol","foreignTableAlias","getTableAlias","query","asJson","addNullCase","withPagination","innerQueryBuilder","parentQueryBuilder","forEach","where","fragment","alias","description","tags","backwardDescription","args","resolve","data","_args","_context","resolveInfo","safeAlias","pgFieldIntrospection","isPgBackwardSingleRelationField","foreignSingleFieldName","makeFields","isConnection","manyRelationFieldName","manyRelationByKeys","manyRelationByKeysSimple","ConnectionType","TableType","withPaginationAsFields","asJsonAggregate","beforeLock","isOrderUnique","cursorPrefix","orderBy","setOrderIsUnique","connection","deprecationReason","isPgFieldConnection","isPgFieldSimpleCollection","isPgBackwardRelationField"],"mappings":"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","file":"PgBackwardRelationPlugin.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\n\nimport type { Plugin } from \"graphile-build\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nconst OMIT = 0;\nconst DEPRECATED = 1;\nconst ONLY = 2;\n\nexport default (function PgBackwardRelationPlugin(\n  builder,\n  { pgLegacyRelations, pgSimpleCollections }\n) {\n  const hasConnections = pgSimpleCollections !== \"only\";\n  const hasSimpleCollections =\n    pgSimpleCollections === \"only\" || pgSimpleCollections === \"both\";\n  const legacyRelationMode =\n    {\n      only: ONLY,\n      deprecated: DEPRECATED,\n    }[pgLegacyRelations] || OMIT;\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      getTypeByName,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      getSafeAliasFromResolveInfo,\n      getSafeAliasFromAlias,\n      graphql: { GraphQLNonNull, GraphQLList },\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgAddStartEndCursor: addStartEndCursor,\n      pgOmit: omit,\n      sqlCommentByAddingTags,\n      describePgEntity,\n    } = build;\n    const {\n      scope: { isPgRowType, pgIntrospection: foreignTable },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (!isPgRowType || !foreignTable || foreignTable.kind !== \"class\") {\n      return fields;\n    }\n    // This is a relation in which WE are foreign\n    const foreignKeyConstraints = foreignTable.foreignConstraints.filter(\n      con => con.type === \"f\"\n    );\n    const foreignTableTypeName = inflection.tableType(foreignTable);\n    const gqlForeignTableType = pgGetGqlTypeByTypeIdAndModifier(\n      foreignTable.type.id,\n      null\n    );\n    if (!gqlForeignTableType) {\n      debug(\n        `Could not determine type for foreign table with id ${\n          foreignTable.type.id\n        }`\n      );\n      return fields;\n    }\n\n    return extend(\n      fields,\n      foreignKeyConstraints.reduce((memo, constraint) => {\n        if (omit(constraint, \"read\")) {\n          return memo;\n        }\n        const table = introspectionResultsByKind.classById[constraint.classId];\n        const tableTypeName = inflection.tableType(table);\n        const gqlTableType = pgGetGqlTypeByTypeIdAndModifier(\n          table.type.id,\n          null\n        );\n        if (!gqlTableType) {\n          debug(\n            `Could not determine type for table with id ${constraint.classId}`\n          );\n          return memo;\n        }\n        if (!table) {\n          throw new Error(\n            `Could not find the table that referenced us (constraint: ${\n              constraint.name\n            })`\n          );\n        }\n        const schema = table.namespace;\n\n        const keys = constraint.keyAttributes;\n        const foreignKeys = constraint.foreignKeyAttributes;\n        if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n          throw new Error(\"Could not find key columns!\");\n        }\n        if (keys.some(key => omit(key, \"read\"))) {\n          return memo;\n        }\n        if (foreignKeys.some(key => omit(key, \"read\"))) {\n          return memo;\n        }\n        const isUnique = !!table.constraints.find(\n          c =>\n            (c.type === \"p\" || c.type === \"u\") &&\n            c.keyAttributeNums.length === keys.length &&\n            c.keyAttributeNums.every((n, i) => keys[i].num === n)\n        );\n\n        const isDeprecated = isUnique && legacyRelationMode === DEPRECATED;\n\n        const singleRelationFieldName = isUnique\n          ? inflection.singleRelationByKeysBackwards(\n              keys,\n              table,\n              foreignTable,\n              constraint\n            )\n          : null;\n\n        const primaryKeyConstraint = table.primaryKeyConstraint;\n        const primaryKeys =\n          primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n\n        const shouldAddSingleRelation = isUnique && legacyRelationMode !== ONLY;\n\n        const shouldAddManyRelation =\n          !isUnique ||\n          legacyRelationMode === DEPRECATED ||\n          legacyRelationMode === ONLY;\n\n        if (\n          shouldAddSingleRelation &&\n          !omit(table, \"read\") &&\n          singleRelationFieldName\n        ) {\n          memo = extend(\n            memo,\n            {\n              [singleRelationFieldName]: fieldWithHooks(\n                singleRelationFieldName,\n                ({\n                  getDataFromParsedResolveInfoFragment,\n                  addDataGenerator,\n                }) => {\n                  addDataGenerator(parsedResolveInfoFragment => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(() => {\n                          const resolveData = getDataFromParsedResolveInfoFragment(\n                            parsedResolveInfoFragment,\n                            gqlTableType\n                          );\n                          const tableAlias = sql.identifier(Symbol());\n                          const foreignTableAlias = queryBuilder.getTableAlias();\n                          const query = queryFromResolveData(\n                            sql.identifier(schema.name, table.name),\n                            tableAlias,\n                            resolveData,\n                            {\n                              asJson: true,\n                              addNullCase: true,\n                              withPagination: false,\n                            },\n                            innerQueryBuilder => {\n                              innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                              keys.forEach((key, i) => {\n                                innerQueryBuilder.where(\n                                  sql.fragment`${tableAlias}.${sql.identifier(\n                                    key.name\n                                  )} = ${foreignTableAlias}.${sql.identifier(\n                                    foreignKeys[i].name\n                                  )}`\n                                );\n                              });\n                            }\n                          );\n                          return sql.fragment`(${query})`;\n                        }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                      },\n                    };\n                  });\n                  return {\n                    description:\n                      constraint.tags.backwardDescription ||\n                      `Reads a single \\`${tableTypeName}\\` that is related to this \\`${foreignTableTypeName}\\`.`,\n                    type: gqlTableType,\n                    args: {},\n                    resolve: (data, _args, _context, resolveInfo) => {\n                      const safeAlias = getSafeAliasFromResolveInfo(\n                        resolveInfo\n                      );\n                      return data[safeAlias];\n                    },\n                  };\n                },\n                {\n                  pgFieldIntrospection: table,\n                  isPgBackwardSingleRelationField: true,\n                }\n              ),\n            },\n            `Backward relation (single) for ${describePgEntity(\n              constraint\n            )}. To rename this relation with smart comments:\\n\\n  ${sqlCommentByAddingTags(\n              constraint,\n              {\n                foreignSingleFieldName: \"newNameHere\",\n              }\n            )}`\n          );\n        }\n        function makeFields(isConnection) {\n          if (isUnique && !isConnection) {\n            // Don't need this, use the singular instead\n            return;\n          }\n          if (shouldAddManyRelation && !omit(table, \"many\")) {\n            const manyRelationFieldName = isConnection\n              ? inflection.manyRelationByKeys(\n                  keys,\n                  table,\n                  foreignTable,\n                  constraint\n                )\n              : inflection.manyRelationByKeysSimple(\n                  keys,\n                  table,\n                  foreignTable,\n                  constraint\n                );\n\n            memo = extend(\n              memo,\n              {\n                [manyRelationFieldName]: fieldWithHooks(\n                  manyRelationFieldName,\n                  ({\n                    getDataFromParsedResolveInfoFragment,\n                    addDataGenerator,\n                  }) => {\n                    addDataGenerator(parsedResolveInfoFragment => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.select(() => {\n                            const resolveData = getDataFromParsedResolveInfoFragment(\n                              parsedResolveInfoFragment,\n                              isConnection ? ConnectionType : TableType\n                            );\n                            const tableAlias = sql.identifier(Symbol());\n                            const foreignTableAlias = queryBuilder.getTableAlias();\n                            const query = queryFromResolveData(\n                              sql.identifier(schema.name, table.name),\n                              tableAlias,\n                              resolveData,\n                              {\n                                withPagination: isConnection,\n                                withPaginationAsFields: false,\n                                asJsonAggregate: !isConnection,\n                              },\n                              innerQueryBuilder => {\n                                innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                                if (primaryKeys) {\n                                  innerQueryBuilder.beforeLock(\n                                    \"orderBy\",\n                                    () => {\n                                      // append order by primary key to the list of orders\n                                      if (\n                                        !innerQueryBuilder.isOrderUnique(false)\n                                      ) {\n                                        innerQueryBuilder.data.cursorPrefix = [\n                                          \"primary_key_asc\",\n                                        ];\n                                        primaryKeys.forEach(key => {\n                                          innerQueryBuilder.orderBy(\n                                            sql.fragment`${innerQueryBuilder.getTableAlias()}.${sql.identifier(\n                                              key.name\n                                            )}`,\n                                            true\n                                          );\n                                        });\n                                        innerQueryBuilder.setOrderIsUnique();\n                                      }\n                                    }\n                                  );\n                                }\n\n                                keys.forEach((key, i) => {\n                                  innerQueryBuilder.where(\n                                    sql.fragment`${tableAlias}.${sql.identifier(\n                                      key.name\n                                    )} = ${foreignTableAlias}.${sql.identifier(\n                                      foreignKeys[i].name\n                                    )}`\n                                  );\n                                });\n                              }\n                            );\n                            return sql.fragment`(${query})`;\n                          }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                        },\n                      };\n                    });\n                    const ConnectionType = getTypeByName(\n                      inflection.connection(gqlTableType.name)\n                    );\n                    const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                      table.type.id,\n                      null\n                    );\n                    return {\n                      description:\n                        constraint.tags.backwardDescription ||\n                        `Reads and enables pagination through a set of \\`${tableTypeName}\\`.`,\n                      type: isConnection\n                        ? new GraphQLNonNull(ConnectionType)\n                        : new GraphQLNonNull(\n                            new GraphQLList(new GraphQLNonNull(TableType))\n                          ),\n                      args: {},\n                      resolve: (data, _args, _context, resolveInfo) => {\n                        const safeAlias = getSafeAliasFromResolveInfo(\n                          resolveInfo\n                        );\n                        if (isConnection) {\n                          return addStartEndCursor(data[safeAlias]);\n                        } else {\n                          return data[safeAlias];\n                        }\n                      },\n                      ...(isDeprecated\n                        ? {\n                            deprecationReason:\n                              // $FlowFixMe\n                              `Please use ${singleRelationFieldName} instead`,\n                          }\n                        : null),\n                    };\n                  },\n                  {\n                    isPgFieldConnection: isConnection,\n                    isPgFieldSimpleCollection: !isConnection,\n                    isPgBackwardRelationField: true,\n                    pgFieldIntrospection: table,\n                  }\n                ),\n              },\n\n              `Backward relation (${\n                isConnection ? \"connection\" : \"simple collection\"\n              }) for ${describePgEntity(\n                constraint\n              )}. To rename this relation with smart comments:\\n\\n  ${sqlCommentByAddingTags(\n                constraint,\n                {\n                  [isConnection\n                    ? \"foreignFieldName\"\n                    : \"foreignSimpleFieldName\"]: \"newNameHere\",\n                }\n              )}`\n            );\n          }\n        }\n        if (hasConnections) {\n          makeFields(true);\n        }\n        if (hasSimpleCollections) {\n          makeFields(false);\n        }\n        return memo;\n      }, {}),\n      `Adding backward relations for ${Self.name}`\n    );\n  });\n}: Plugin);\n"]}