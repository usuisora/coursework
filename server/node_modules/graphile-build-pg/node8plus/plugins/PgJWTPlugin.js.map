{"version":3,"sources":["../../src/plugins/PgJWTPlugin.js"],"names":["PgJWTPlugin","builder","pgJwtTypeIdentifier","pgJwtSecret","hook","_","build","newWithHooks","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","pgRegisterGqlTypeByTypeId","pg2GqlMapper","pgTweaksByTypeId","pgTweakFragmentForTypeAndModifier","graphql","GraphQLScalarType","inflection","pgParseIdentifier","parseIdentifier","describePgEntity","Error","namespaceName","entityName","typeName","compositeClass","class","find","table","isSelectable","isInsertable","isUpdatable","isDeletable","name","compositeType","type","id","attributes","compositeTypeName","tableType","cb","JWTType","description","serialize","value","token","reduce","memo","attr","Object","assign","aud","audience","iss","issuer","exp","expiresIn","__origin","isPgJwtType","map","values","some","v","unmap","fragment","join","literal","identifier","typeModifier"],"mappings":"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","file":"PgJWTPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport { sign as signJwt } from \"jsonwebtoken\";\n\nexport default (function PgJWTPlugin(\n  builder,\n  { pgJwtTypeIdentifier, pgJwtSecret }\n) {\n  builder.hook(\"init\", (_, build) => {\n    const {\n      newWithHooks,\n      pgSql: sql,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgRegisterGqlTypeByTypeId,\n      pg2GqlMapper,\n      pgTweaksByTypeId,\n      pgTweakFragmentForTypeAndModifier,\n      graphql: { GraphQLScalarType },\n      inflection,\n      pgParseIdentifier: parseIdentifier,\n      describePgEntity,\n    } = build;\n\n    if (!pgJwtTypeIdentifier) {\n      return _;\n    }\n    if (!pgJwtSecret) {\n      throw new Error(\"pgJwtTypeIdentifier was specified without pgJwtSecret\");\n    }\n    const { namespaceName, entityName: typeName } = parseIdentifier(\n      pgJwtTypeIdentifier\n    );\n\n    const compositeClass = introspectionResultsByKind.class.find(\n      table =>\n        !table.isSelectable &&\n        !table.isInsertable &&\n        !table.isUpdatable &&\n        !table.isDeletable &&\n        table.name === typeName &&\n        table.namespaceName === namespaceName\n    );\n    if (!compositeClass) {\n      throw new Error(\n        `Could not find JWT type '\"${namespaceName}\".\"${typeName}\"'`\n      );\n    }\n    const compositeType = compositeClass.type;\n    if (!compositeType) {\n      throw new Error(\"Could not determine the type for JWT type\");\n    }\n    if (pg2GqlMapper[compositeType.id]) {\n      throw new Error(\"JWT type has already been overridden?\");\n    }\n    const attributes = compositeClass.attributes;\n\n    const compositeTypeName = inflection.tableType(compositeClass);\n\n    // NOTE: we deliberately do not create an input type\n    pgRegisterGqlTypeByTypeId(compositeType.id, cb => {\n      const JWTType = newWithHooks(\n        GraphQLScalarType,\n        {\n          name: compositeTypeName,\n          description:\n            \"A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519) which securely represents claims between two parties.\",\n          serialize(value) {\n            const token = attributes.reduce((memo, attr) => {\n              memo[attr.name] = value[attr.name];\n              return memo;\n            }, {});\n            return signJwt(\n              token,\n              pgJwtSecret,\n              Object.assign(\n                {},\n                token.aud\n                  ? null\n                  : {\n                      audience: \"postgraphile\",\n                    },\n                token.iss\n                  ? null\n                  : {\n                      issuer: \"postgraphile\",\n                    },\n                token.exp\n                  ? null\n                  : {\n                      expiresIn: \"1 day\",\n                    }\n              )\n            );\n          },\n        },\n        {\n          __origin: `Adding JWT type based on ${describePgEntity(\n            compositeType\n          )}`,\n          isPgJwtType: true,\n        }\n      );\n      cb(JWTType);\n\n      pg2GqlMapper[compositeType.id] = {\n        map: value => {\n          if (!value) return null;\n          const values = Object.values(value);\n          if (values.some(v => v != null)) {\n            return value;\n          }\n          return null;\n        },\n        unmap: () => {\n          throw new Error(\n            \"We don't support passing a JWT token into GraphQL currently\"\n          );\n        },\n      };\n\n      pgTweaksByTypeId[compositeType.id] = fragment =>\n        sql.fragment`json_build_object(${sql.join(\n          compositeClass.attributes.map(\n            attr =>\n              sql.fragment`${sql.literal(\n                attr.name\n              )}::text, ${pgTweakFragmentForTypeAndModifier(\n                sql.fragment`(${fragment}).${sql.identifier(attr.name)}`,\n                attr.type,\n                attr.typeModifier,\n                {}\n              )}`\n          ),\n          \", \"\n        )})`;\n    });\n    return _;\n  });\n}: Plugin);\n"]}