{"version":3,"sources":["../../src/plugins/PgRowNode.js"],"names":["PgRowNode","builder","hook","object","build","context","addNodeFetcherForTypeName","pgSql","sql","gql2pg","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","scope","isPgRowType","pgIntrospection","table","namespace","sqlFullTableName","identifier","name","primaryKeyConstraint","primaryKeys","keyAttributes","data","identifiers","pgClient","parsedResolveInfoFragment","ReturnType","resolveData","length","Error","query","undefined","queryBuilder","forEach","key","idx","where","fragment","getTableAlias","type","typeModifier","text","values","compile","debugSql","enabled","rows","row","fields","nodeIdFieldName","getTypeAndIdentifiersFromNodeId","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","graphql","GraphQLNonNull","GraphQLID","inflection","describePgEntity","sqlCommentByAddingTags","isRootQuery","fieldWithHooks","class","reduce","memo","TableType","id","fieldName","tableNode","getDataFromParsedResolveInfoFragment","description","args","resolve","parent","resolveInfo","nodeId","Type","e","isPgNodeQuery","pgFieldIntrospection"],"mappings":"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","file":"PgRowNode.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugSql from \"./debugSql\";\n\nexport default (async function PgRowNode(builder) {\n  builder.hook(\"GraphQLObjectType\", (object, build, context) => {\n    const {\n      addNodeFetcherForTypeName,\n      pgSql: sql,\n      gql2pg,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n    } = build;\n    const {\n      scope: { isPgRowType, pgIntrospection: table },\n    } = context;\n\n    if (!addNodeFetcherForTypeName) {\n      // Node plugin must be disabled.\n      return object;\n    }\n    if (!isPgRowType || !table.namespace || omit(table, \"read\")) {\n      return object;\n    }\n    const sqlFullTableName = sql.identifier(table.namespace.name, table.name);\n    const primaryKeyConstraint = table.primaryKeyConstraint;\n    if (!primaryKeyConstraint) {\n      return object;\n    }\n    const primaryKeys =\n      primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n\n    addNodeFetcherForTypeName(\n      object.name,\n      async (\n        data,\n        identifiers,\n        { pgClient },\n        parsedResolveInfoFragment,\n        ReturnType,\n        resolveData\n      ) => {\n        if (identifiers.length !== primaryKeys.length) {\n          throw new Error(\"Invalid ID\");\n        }\n        const query = queryFromResolveData(\n          sqlFullTableName,\n          undefined,\n          resolveData,\n          {},\n          queryBuilder => {\n            primaryKeys.forEach((key, idx) => {\n              queryBuilder.where(\n                sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                  key.name\n                )} = ${gql2pg(\n                  identifiers[idx],\n                  primaryKeys[idx].type,\n                  primaryKeys[idx].typeModifier\n                )}`\n              );\n            });\n          }\n        );\n        const { text, values } = sql.compile(query);\n        if (debugSql.enabled) debugSql(text);\n        const {\n          rows: [row],\n        } = await pgClient.query(text, values);\n        return row;\n      }\n    );\n    return object;\n  });\n\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      nodeIdFieldName,\n      getTypeAndIdentifiersFromNodeId,\n      extend,\n      parseResolveInfo,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      gql2pg,\n      graphql: { GraphQLNonNull, GraphQLID },\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const {\n      scope: { isRootQuery },\n      fieldWithHooks,\n    } = context;\n\n    if (!isRootQuery || !nodeIdFieldName) {\n      return fields;\n    }\n\n    return extend(\n      fields,\n      introspectionResultsByKind.class.reduce((memo, table) => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!table.namespace) return memo;\n        if (omit(table, \"read\")) return memo;\n\n        const TableType = pgGetGqlTypeByTypeIdAndModifier(table.type.id, null);\n        const sqlFullTableName = sql.identifier(\n          table.namespace.name,\n          table.name\n        );\n        if (TableType) {\n          const primaryKeyConstraint = table.primaryKeyConstraint;\n          if (!primaryKeyConstraint) {\n            return memo;\n          }\n          const primaryKeys =\n            primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n          const fieldName = inflection.tableNode(table);\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                ({ getDataFromParsedResolveInfoFragment }) => {\n                  return {\n                    description: `Reads a single \\`${\n                      TableType.name\n                    }\\` using its globally unique \\`ID\\`.`,\n                    type: TableType,\n                    args: {\n                      [nodeIdFieldName]: {\n                        description: `The globally unique \\`ID\\` to be used in selecting a single \\`${\n                          TableType.name\n                        }\\`.`,\n                        type: new GraphQLNonNull(GraphQLID),\n                      },\n                    },\n                    async resolve(parent, args, { pgClient }, resolveInfo) {\n                      const nodeId = args[nodeIdFieldName];\n                      try {\n                        const {\n                          Type,\n                          identifiers,\n                        } = getTypeAndIdentifiersFromNodeId(nodeId);\n                        if (Type !== TableType) {\n                          throw new Error(\"Mismatched type\");\n                        }\n                        if (identifiers.length !== primaryKeys.length) {\n                          throw new Error(\"Invalid ID\");\n                        }\n\n                        const parsedResolveInfoFragment = parseResolveInfo(\n                          resolveInfo\n                        );\n                        const resolveData = getDataFromParsedResolveInfoFragment(\n                          parsedResolveInfoFragment,\n                          TableType\n                        );\n                        const query = queryFromResolveData(\n                          sqlFullTableName,\n                          undefined,\n                          resolveData,\n                          {},\n                          queryBuilder => {\n                            primaryKeys.forEach((key, idx) => {\n                              queryBuilder.where(\n                                sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                  key.name\n                                )} = ${gql2pg(\n                                  identifiers[idx],\n                                  primaryKeys[idx].type,\n                                  primaryKeys[idx].typeModifier\n                                )}`\n                              );\n                            });\n                          }\n                        );\n                        const { text, values } = sql.compile(query);\n                        if (debugSql.enabled) debugSql(text);\n                        const {\n                          rows: [row],\n                        } = await pgClient.query(text, values);\n                        return row;\n                      } catch (e) {\n                        return null;\n                      }\n                    },\n                  };\n                },\n                {\n                  isPgNodeQuery: true,\n                  pgFieldIntrospection: table,\n                }\n              ),\n            },\n            `Adding row by globally unique identifier field for ${describePgEntity(\n              table\n            )}. You can rename this table via:\\n\\n  ${sqlCommentByAddingTags(\n              table,\n              { name: \"newNameHere\" }\n            )}`\n          );\n        }\n        return memo;\n      }, {}),\n      `Adding \"row by node ID\" fields to root Query type`\n    );\n  });\n}: Plugin);\n"]}