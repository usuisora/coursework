{"version":3,"sources":["../../src/plugins/PgComputedColumnsPlugin.js"],"names":["getComputedColumnDetails","build","table","proc","isStable","namespaceId","name","startsWith","argTypeIds","length","type","id","argTypes","reduce","prev","typeId","idx","argModes","push","pgIntrospectionResultsByKind","typeById","slice","some","class","isSelectable","pseudoColumnName","substr","PgComputedColumnsPlugin","builder","pgSimpleCollections","hasConnections","hasSimpleCollections","hook","fields","context","scope","isPgRowType","isPgCompoundType","isInputType","pgIntrospection","fieldWithHooks","Self","kind","namespace","extend","introspectionResultsByKind","inflection","pgOmit","omit","pgMakeProcField","makeProcField","swallowError","describePgEntity","sqlCommentByAddingTags","tableType","Error","procedure","memo","computedColumnDetails","makeField","forceList","fieldName","computedColumnList","computedColumn","computed","e","returnsSet"],"mappings":"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","file":"PgComputedColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin, Build } from \"graphile-build\";\nimport type { PgClass, PgProc } from \"./PgIntrospectionPlugin\";\n\n// This interface is not official yet, don't rely on it.\nexport const getComputedColumnDetails = (\n  build: Build,\n  table: PgClass,\n  proc: PgProc\n) => {\n  if (!proc.isStable) return null;\n  if (proc.namespaceId !== table.namespaceId) return null;\n  if (!proc.name.startsWith(`${table.name}_`)) return null;\n  if (proc.argTypeIds.length < 1) return null;\n  if (proc.argTypeIds[0] !== table.type.id) return null;\n\n  const argTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n    if (\n      proc.argModes.length === 0 || // all args are `in`\n      proc.argModes[idx] === \"i\" || // this arg is `in`\n      proc.argModes[idx] === \"b\" // this arg is `inout`\n    ) {\n      prev.push(build.pgIntrospectionResultsByKind.typeById[typeId]);\n    }\n    return prev;\n  }, []);\n  if (\n    argTypes\n      .slice(1)\n      .some(type => type.type === \"c\" && type.class && type.class.isSelectable)\n  ) {\n    // Accepts two input tables? Skip.\n    return null;\n  }\n\n  const pseudoColumnName = proc.name.substr(table.name.length + 1);\n  return { argTypes, pseudoColumnName };\n};\n\nexport default (function PgComputedColumnsPlugin(\n  builder,\n  { pgSimpleCollections }\n) {\n  const hasConnections = pgSimpleCollections !== \"only\";\n  const hasSimpleCollections =\n    pgSimpleCollections === \"only\" || pgSimpleCollections === \"both\";\n\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isInputType,\n        pgIntrospection: table,\n      },\n      fieldWithHooks,\n      Self,\n    } = context;\n\n    if (\n      isInputType ||\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\" ||\n      !table.namespace\n    ) {\n      return fields;\n    }\n\n    const {\n      extend,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      inflection,\n      pgOmit: omit,\n      pgMakeProcField: makeProcField,\n      swallowError,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const tableType = table.type;\n    if (!tableType) {\n      throw new Error(\"Could not determine the type for this table\");\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.procedure.reduce((memo, proc) => {\n        if (omit(proc, \"execute\")) return memo;\n        const computedColumnDetails = getComputedColumnDetails(\n          build,\n          table,\n          proc\n        );\n        if (!computedColumnDetails) return memo;\n        const { pseudoColumnName } = computedColumnDetails;\n        function makeField(forceList) {\n          const fieldName = forceList\n            ? inflection.computedColumnList(pseudoColumnName, proc, table)\n            : inflection.computedColumn(pseudoColumnName, proc, table);\n          try {\n            memo = extend(\n              memo,\n              {\n                [fieldName]: makeProcField(fieldName, proc, build, {\n                  fieldWithHooks,\n                  computed: true,\n                  forceList,\n                }),\n              },\n              `Adding computed column for ${describePgEntity(\n                proc\n              )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n                proc,\n                {\n                  fieldName: \"newNameHere\",\n                }\n              )}`\n            );\n          } catch (e) {\n            swallowError(e);\n          }\n        }\n        if (!proc.returnsSet || hasConnections) {\n          makeField(false);\n        }\n        if (proc.returnsSet && hasSimpleCollections) {\n          makeField(true);\n        }\n        return memo;\n      }, {}),\n      `Adding computed column to '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}