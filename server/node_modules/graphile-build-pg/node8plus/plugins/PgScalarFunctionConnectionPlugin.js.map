{"version":3,"sources":["../../src/plugins/PgScalarFunctionConnectionPlugin.js"],"names":["base64","str","Buffer","from","String","toString","PgScalarFunctionConnectionPlugin","builder","hook","_","build","newWithHooks","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLList","GraphQLString","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","pgField","Cursor","procedure","forEach","proc","returnsSet","namespace","returnType","typeById","returnTypeId","returnTypeTable","classById","classId","id","NodeType","EdgeType","name","scalarFunctionEdge","description","fields","fieldWithHooks","cursor","addDataGenerator","usesCursor","type","resolve","data","JSON","stringify","__cursor","isCursorField","node","value","__origin","isEdgeType","nodeType","pgIntrospection","scalarFunctionConnection","nodes","map","entry","edges","hoistCursor","isConnectionType","edgeType"],"mappings":"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","file":"PgScalarFunctionConnectionPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nexport default (function PgScalarFunctionConnectionPlugin(builder) {\n  builder.hook(\"init\", (_, build) => {\n    const {\n      newWithHooks,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      getTypeByName,\n      pgGetGqlTypeByTypeIdAndModifier,\n      graphql: {\n        GraphQLObjectType,\n        GraphQLNonNull,\n        GraphQLList,\n        GraphQLString,\n      },\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n      pgField,\n    } = build;\n\n    const Cursor = getTypeByName(\"Cursor\");\n    introspectionResultsByKind.procedure.forEach(proc => {\n      // PERFORMANCE: These used to be .filter(...) calls\n      if (!proc.returnsSet) return;\n      if (!proc.namespace) return;\n      if (omit(proc, \"execute\")) return;\n\n      const returnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n      const returnTypeTable =\n        introspectionResultsByKind.classById[returnType.classId];\n      if (returnTypeTable) {\n        // Just use the standard table connection from PgTablesPlugin\n        return;\n      }\n      if (returnType.id === \"2249\") {\n        // Defer handling to PgRecordFunctionConnectionPlugin\n        return;\n      }\n      // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod\n      // on function arguments and return types, however maybe a later\n      // version of PG will?\n      const NodeType =\n        pgGetGqlTypeByTypeIdAndModifier(returnType.id, null) || GraphQLString;\n      const EdgeType = newWithHooks(\n        GraphQLObjectType,\n        {\n          name: inflection.scalarFunctionEdge(proc),\n          description: `A \\`${NodeType.name}\\` edge in the connection.`,\n          fields: ({ fieldWithHooks }) => {\n            return {\n              cursor: fieldWithHooks(\n                \"cursor\",\n                ({ addDataGenerator }) => {\n                  addDataGenerator(() => ({\n                    usesCursor: [true],\n                  }));\n                  return {\n                    description: \"A cursor for use in pagination.\",\n                    type: Cursor,\n                    resolve(data) {\n                      return base64(JSON.stringify(data.__cursor));\n                    },\n                  };\n                },\n                {\n                  isCursorField: true,\n                }\n              ),\n              node: {\n                description: `The \\`${NodeType.name}\\` at the end of the edge.`,\n                type: NodeType,\n                resolve(data) {\n                  return data.value;\n                },\n              },\n            };\n          },\n        },\n        {\n          __origin: `Adding function result edge type for ${describePgEntity(\n            proc\n          )}. You can rename the function's GraphQL field (and its dependent types) via:\\n\\n  ${sqlCommentByAddingTags(\n            proc,\n            {\n              name: \"newNameHere\",\n            }\n          )}`,\n          isEdgeType: true,\n          nodeType: NodeType,\n          pgIntrospection: proc,\n        }\n      );\n\n      /*const ConnectionType = */\n      newWithHooks(\n        GraphQLObjectType,\n        {\n          name: inflection.scalarFunctionConnection(proc),\n          description: `A connection to a list of \\`${NodeType.name}\\` values.`,\n          fields: ({ fieldWithHooks }) => {\n            return {\n              nodes: pgField(build, fieldWithHooks, \"nodes\", {\n                description: `A list of \\`${NodeType.name}\\` objects.`,\n                type: new GraphQLNonNull(new GraphQLList(NodeType)),\n                resolve(data) {\n                  return data.data.map(entry => entry.value);\n                },\n              }),\n              edges: pgField(\n                build,\n                fieldWithHooks,\n                \"edges\",\n                {\n                  description: `A list of edges which contains the \\`${\n                    NodeType.name\n                  }\\` and cursor to aid in pagination.`,\n                  type: new GraphQLNonNull(\n                    new GraphQLList(new GraphQLNonNull(EdgeType))\n                  ),\n                  resolve(data) {\n                    return data.data;\n                  },\n                },\n                {},\n                false,\n                {\n                  hoistCursor: true,\n                }\n              ),\n            };\n          },\n        },\n        {\n          __origin: `Adding function connection type for ${describePgEntity(\n            proc\n          )}. You can rename the function's GraphQL field (and its dependent types) via:\\n\\n  ${sqlCommentByAddingTags(\n            proc,\n            {\n              name: \"newNameHere\",\n            }\n          )}`,\n          isConnectionType: true,\n          edgeType: EdgeType,\n          nodeType: NodeType,\n          pgIntrospection: proc,\n        }\n      );\n    });\n    return _;\n  });\n}: Plugin);\n"]}