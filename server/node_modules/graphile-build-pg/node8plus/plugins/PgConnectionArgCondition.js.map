{"version":3,"sources":["../../src/plugins/PgConnectionArgCondition.js"],"names":["PgConnectionArgCondition","builder","hook","_","build","newWithHooks","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlInputTypeByTypeIdAndModifier","graphql","GraphQLInputObjectType","GraphQLString","pgColumnFilter","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","class","forEach","table","isSelectable","namespace","tableTypeName","tableType","description","name","conditionType","fields","context","fieldWithHooks","attributes","reduce","memo","attr","fieldName","column","extend","type","typeId","typeModifier","isPgConnectionConditionInputField","__origin","pgIntrospection","isPgCondition","args","pgSql","sql","gql2pg","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","scope","isPgFieldConnection","isPgFieldSimpleCollection","pgFieldIntrospection","pgFieldIntrospectionTable","addArgDataGenerator","Self","field","shouldAddCondition","proc","kind","tags","filterable","TableType","id","TableConditionType","relevantAttributes","filter","connectionCondition","condition","pgQuery","queryBuilder","val","where","fragment","getTableAlias","identifier"],"mappings":"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","file":"PgConnectionArgCondition.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nexport default (function PgConnectionArgCondition(builder) {\n  builder.hook(\"init\", (_, build) => {\n    const {\n      newWithHooks,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      graphql: { GraphQLInputObjectType, GraphQLString },\n      pgColumnFilter,\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    introspectionResultsByKind.class.forEach(table => {\n      // PERFORMANCE: These used to be .filter(...) calls\n      if (!table.isSelectable || omit(table, \"filter\")) return;\n      if (!table.namespace) return;\n\n      const tableTypeName = inflection.tableType(table);\n      /* const TableConditionType = */\n      newWithHooks(\n        GraphQLInputObjectType,\n        {\n          description: `A condition to be used against \\`${tableTypeName}\\` object types. All fields are tested for equality and combined with a logical ‘and.’`,\n          name: inflection.conditionType(inflection.tableType(table)),\n          fields: context => {\n            const { fieldWithHooks } = context;\n            return table.attributes.reduce((memo, attr) => {\n              // PERFORMANCE: These used to be .filter(...) calls\n              if (!pgColumnFilter(attr, build, context)) return memo;\n              if (omit(attr, \"filter\")) return memo;\n\n              const fieldName = inflection.column(attr);\n              memo = build.extend(\n                memo,\n                {\n                  [fieldName]: fieldWithHooks(\n                    fieldName,\n                    {\n                      description: `Checks for equality with the object’s \\`${fieldName}\\` field.`,\n                      type:\n                        pgGetGqlInputTypeByTypeIdAndModifier(\n                          attr.typeId,\n                          attr.typeModifier\n                        ) || GraphQLString,\n                    },\n                    {\n                      isPgConnectionConditionInputField: true,\n                    }\n                  ),\n                },\n                `Adding condition argument for ${describePgEntity(attr)}`\n              );\n              return memo;\n            }, {});\n          },\n        },\n        {\n          __origin: `Adding condition type for ${describePgEntity(\n            table\n          )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n            table,\n            {\n              name: \"newNameHere\",\n            }\n          )}`,\n          pgIntrospection: table,\n          isPgCondition: true,\n        },\n        true // Conditions might all be filtered\n      );\n    });\n    return _;\n  });\n\n  builder.hook(\n    \"GraphQLObjectType:fields:field:args\",\n    (args, build, context) => {\n      const {\n        pgSql: sql,\n        gql2pg,\n        extend,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgColumnFilter,\n        inflection,\n        pgOmit: omit,\n      } = build;\n      const {\n        scope: {\n          isPgFieldConnection,\n          isPgFieldSimpleCollection,\n          pgFieldIntrospection,\n          pgFieldIntrospectionTable,\n        },\n        addArgDataGenerator,\n        Self,\n        field,\n      } = context;\n\n      const shouldAddCondition =\n        isPgFieldConnection || isPgFieldSimpleCollection;\n      if (!shouldAddCondition) return args;\n\n      const proc =\n        pgFieldIntrospection.kind === \"procedure\" ? pgFieldIntrospection : null;\n      const table =\n        pgFieldIntrospection.kind === \"class\"\n          ? pgFieldIntrospection\n          : proc\n            ? pgFieldIntrospectionTable\n            : null;\n      if (\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace ||\n        omit(table, \"filter\")\n      ) {\n        return args;\n      }\n      if (proc) {\n        if (!proc.tags.filterable) {\n          return args;\n        }\n      }\n\n      const TableType = pgGetGqlTypeByTypeIdAndModifier(table.type.id, null);\n      const TableConditionType = getTypeByName(\n        inflection.conditionType(TableType.name)\n      );\n      if (!TableConditionType) {\n        return args;\n      }\n\n      const relevantAttributes = table.attributes.filter(\n        attr => pgColumnFilter(attr, build, context) && !omit(attr, \"filter\")\n      );\n\n      addArgDataGenerator(function connectionCondition({ condition }) {\n        return {\n          pgQuery: queryBuilder => {\n            if (condition != null) {\n              relevantAttributes.forEach(attr => {\n                const fieldName = inflection.column(attr);\n                const val = condition[fieldName];\n                if (val != null) {\n                  queryBuilder.where(\n                    sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                      attr.name\n                    )} = ${gql2pg(val, attr.type, attr.typeModifier)}`\n                  );\n                } else if (val === null) {\n                  queryBuilder.where(\n                    sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                      attr.name\n                    )} IS NULL`\n                  );\n                }\n              });\n            }\n          },\n        };\n      });\n\n      return extend(\n        args,\n        {\n          condition: {\n            description:\n              \"A condition to be used in determining which values should be returned by the collection.\",\n            type: TableConditionType,\n          },\n        },\n        `Adding condition to connection field '${field.name}' of '${Self.name}'`\n      );\n    }\n  );\n}: Plugin);\n"]}