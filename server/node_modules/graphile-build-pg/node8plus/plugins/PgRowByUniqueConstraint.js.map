{"version":3,"sources":["../../src/plugins/PgRowByUniqueConstraint.js"],"names":["PgRowByUniqueConstraint","builder","hook","fields","build","context","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","gql2pg","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","scope","isRootQuery","fieldWithHooks","class","reduce","memo","table","namespace","TableType","type","id","sqlFullTableName","identifier","name","uniqueConstraints","constraints","filter","con","forEach","constraint","keys","keyAttributes","some","key","every","_","Error","fieldName","rowByUniqueKeys","getDataFromParsedResolveInfoFragment","args","InputType","typeId","typeModifier","column","resolve","parent","pgClient","resolveInfo","parsedResolveInfoFragment","resolveData","query","undefined","queryBuilder","where","fragment","getTableAlias","text","values","compile","debugSql","enabled","rows","row","isPgRowByUniqueConstraintField","pgFieldIntrospection"],"mappings":"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","file":"PgRowByUniqueConstraint.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugSql from \"./debugSql\";\n\nexport default (async function PgRowByUniqueConstraint(builder) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      parseResolveInfo,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      gql2pg,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      graphql: { GraphQLNonNull },\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n    } = build;\n    const {\n      scope: { isRootQuery },\n      fieldWithHooks,\n    } = context;\n\n    if (!isRootQuery) {\n      return fields;\n    }\n\n    return extend(\n      fields,\n      introspectionResultsByKind.class.reduce((memo, table) => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!table.namespace) return memo;\n        if (omit(table, \"read\")) return memo;\n\n        const TableType = pgGetGqlTypeByTypeIdAndModifier(table.type.id, null);\n        const sqlFullTableName = sql.identifier(\n          table.namespace.name,\n          table.name\n        );\n        if (TableType) {\n          const uniqueConstraints = table.constraints.filter(\n            con => con.type === \"u\" || con.type === \"p\"\n          );\n          uniqueConstraints.forEach(constraint => {\n            if (omit(constraint, \"read\")) {\n              return;\n            }\n            const keys = constraint.keyAttributes;\n            if (keys.some(key => omit(key, \"read\"))) {\n              return;\n            }\n            if (!keys.every(_ => _)) {\n              throw new Error(\n                \"Consistency error: could not find an attribute!\"\n              );\n            }\n            const fieldName = inflection.rowByUniqueKeys(\n              keys,\n              table,\n              constraint\n            );\n            memo[fieldName] = fieldWithHooks(\n              fieldName,\n              ({ getDataFromParsedResolveInfoFragment }) => {\n                return {\n                  type: TableType,\n                  args: keys.reduce((memo, key) => {\n                    const InputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                      key.typeId,\n                      key.typeModifier\n                    );\n                    if (!InputType) {\n                      throw new Error(\n                        `Could not find input type for key '${\n                          key.name\n                        }' on type '${TableType.name}'`\n                      );\n                    }\n                    memo[inflection.column(key)] = {\n                      type: new GraphQLNonNull(InputType),\n                    };\n                    return memo;\n                  }, {}),\n                  async resolve(parent, args, { pgClient }, resolveInfo) {\n                    const parsedResolveInfoFragment = parseResolveInfo(\n                      resolveInfo\n                    );\n                    const resolveData = getDataFromParsedResolveInfoFragment(\n                      parsedResolveInfoFragment,\n                      TableType\n                    );\n                    const query = queryFromResolveData(\n                      sqlFullTableName,\n                      undefined,\n                      resolveData,\n                      {},\n                      queryBuilder => {\n                        keys.forEach(key => {\n                          queryBuilder.where(\n                            sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                              key.name\n                            )} = ${gql2pg(\n                              args[inflection.column(key)],\n                              key.type,\n                              key.typeModifier\n                            )}`\n                          );\n                        });\n                      }\n                    );\n                    const { text, values } = sql.compile(query);\n                    if (debugSql.enabled) debugSql(text);\n                    const {\n                      rows: [row],\n                    } = await pgClient.query(text, values);\n                    return row;\n                  },\n                };\n              },\n              {\n                isPgRowByUniqueConstraintField: true,\n                pgFieldIntrospection: constraint,\n              }\n            );\n          });\n        }\n        return memo;\n      }, {}),\n      `Adding \"row by unique constraint\" fields to root Query type`\n    );\n  });\n}: Plugin);\n"]}