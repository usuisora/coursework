{"version":3,"sources":["../../src/plugins/PgMutationPayloadEdgePlugin.js"],"names":["PgMutationPayloadEdgePlugin","builder","hook","fields","build","context","extend","getSafeAliasFromResolveInfo","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgSql","sql","graphql","GraphQLList","GraphQLNonNull","inflection","pgOmit","omit","describePgEntity","pgField","scope","isMutationPayload","pgIntrospection","pgIntrospectionTable","fieldWithHooks","Self","table","kind","namespace","isSelectable","TableType","type","id","tableTypeName","name","TableOrderByType","orderByType","TableEdgeType","edge","primaryKeyConstraint","primaryKeys","keyAttributes","canOrderBy","fieldName","edgeField","defaultValueEnum","getValues","find","v","description","args","orderBy","defaultValue","value","resolve","data","rawOrderBy","_context","resolveInfo","safeAlias","Array","isArray","order","some","item","alias","filter","__identifiers","Object","assign","__cursor","map","join","isPgMutationPayloadEdgeField","pgFieldIntrospection","withQueryBuilder","queryBuilder","parsedResolveInfoFragment","aliases","expressions","unique","forEach","specs","itemIsUnique","orders","col","_ascending","expr","fragment","getTableAlias","identifier","push","key","length","select","a","literal"],"mappings":"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","file":"PgMutationPayloadEdgePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport isString from \"lodash/isString\";\n\nexport default (function PgMutationPayloadEdgePlugin(builder) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      getSafeAliasFromResolveInfo,\n      getTypeByName,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgSql: sql,\n      graphql: { GraphQLList, GraphQLNonNull },\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      pgField,\n    } = build;\n    const {\n      scope: { isMutationPayload, pgIntrospection, pgIntrospectionTable },\n      fieldWithHooks,\n      Self,\n    } = context;\n\n    const table = pgIntrospectionTable || pgIntrospection;\n    if (\n      !isMutationPayload ||\n      !table ||\n      table.kind !== \"class\" ||\n      !table.namespace ||\n      !table.isSelectable ||\n      (omit(table, \"all\") && omit(table, \"many\"))\n    ) {\n      return fields;\n    }\n\n    const TableType = pgGetGqlTypeByTypeIdAndModifier(table.type.id, null);\n    const tableTypeName = TableType.name;\n    const TableOrderByType = getTypeByName(\n      inflection.orderByType(tableTypeName)\n    );\n    const TableEdgeType = getTypeByName(inflection.edge(tableTypeName));\n    if (!TableEdgeType) {\n      return fields;\n    }\n\n    const primaryKeyConstraint = table.primaryKeyConstraint;\n    const primaryKeys =\n      primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n    const canOrderBy = !omit(table, \"order\");\n\n    const fieldName = inflection.edgeField(table);\n    const defaultValueEnum =\n      canOrderBy &&\n      (TableOrderByType.getValues().find(v => v.name === \"PRIMARY_KEY_ASC\") ||\n        TableOrderByType.getValues()[0]);\n    return extend(\n      fields,\n      {\n        [fieldName]: pgField(\n          build,\n          fieldWithHooks,\n          fieldName,\n          {\n            description: `An edge for our \\`${tableTypeName}\\`. May be used by Relay 1.`,\n            type: TableEdgeType,\n            args: canOrderBy\n              ? {\n                  orderBy: {\n                    description: `The method to use when ordering \\`${tableTypeName}\\`.`,\n                    type: new GraphQLList(new GraphQLNonNull(TableOrderByType)),\n                    defaultValue: defaultValueEnum && defaultValueEnum.value,\n                  },\n                }\n              : {},\n            resolve(data, { orderBy: rawOrderBy }, _context, resolveInfo) {\n              const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n              const edge = data.data[safeAlias];\n              if (!edge) {\n                return null;\n              }\n              const orderBy =\n                canOrderBy && rawOrderBy\n                  ? Array.isArray(rawOrderBy)\n                    ? rawOrderBy\n                    : [rawOrderBy]\n                  : null;\n              const order =\n                orderBy && orderBy.some(item => item.alias)\n                  ? orderBy.filter(item => item.alias)\n                  : null;\n\n              if (!order) {\n                if (edge.__identifiers) {\n                  return Object.assign({}, edge, {\n                    __cursor: [\"primary_key_asc\", edge.__identifiers],\n                  });\n                } else {\n                  return edge;\n                }\n              }\n\n              return Object.assign({}, edge, {\n                __cursor:\n                  edge[`__order_${order.map(item => item.alias).join(\"__\")}`],\n              });\n            },\n          },\n          {\n            isPgMutationPayloadEdgeField: true,\n            pgFieldIntrospection: table,\n          },\n          false,\n          {\n            withQueryBuilder(queryBuilder, { parsedResolveInfoFragment }) {\n              const {\n                args: { orderBy: rawOrderBy },\n              } = parsedResolveInfoFragment;\n              const orderBy =\n                canOrderBy && rawOrderBy\n                  ? Array.isArray(rawOrderBy)\n                    ? rawOrderBy\n                    : [rawOrderBy]\n                  : null;\n              if (orderBy != null) {\n                const aliases = [];\n                const expressions = [];\n                let unique = false;\n                orderBy.forEach(item => {\n                  const { alias, specs, unique: itemIsUnique } = item;\n                  unique = unique || itemIsUnique;\n                  const orders = Array.isArray(specs[0]) ? specs : [specs];\n                  orders.forEach(([col, _ascending]) => {\n                    if (!col) {\n                      return;\n                    }\n                    const expr = isString(col)\n                      ? sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                          col\n                        )}`\n                      : col;\n                    expressions.push(expr);\n                  });\n                  if (alias == null) return;\n                  aliases.push(alias);\n                });\n                if (!unique && primaryKeys) {\n                  // Add PKs\n                  primaryKeys.forEach(key => {\n                    expressions.push(\n                      sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                        key.name\n                      )}`\n                    );\n                  });\n                }\n                if (aliases.length) {\n                  queryBuilder.select(\n                    sql.fragment`json_build_array(${sql.join(\n                      aliases.map(a => sql.fragment`${sql.literal(a)}::text`),\n                      \", \"\n                    )}, json_build_array(${sql.join(expressions, \", \")}))`,\n                    \"__order_\" + aliases.join(\"__\")\n                  );\n                }\n              }\n            },\n          }\n        ),\n      },\n      `Adding edge field for table ${describePgEntity(\n        table\n      )} to mutation payload '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}