{"version":3,"sources":["../../src/plugins/viaTemporaryTable.js"],"names":["sql","viaTemporaryTable","pgClient","sqlTypeIdentifier","sqlMutationQuery","sqlResultSourceAlias","sqlResultQuery","isPgClassLike","pgRecordInfo","undefined","isPgRecord","outputArgTypes","outputArgNames","performQuery","sqlQuery","text","values","compile","debugSql","enabled","query","rows","selectionField","join","map","outputArgName","idx","identifier","result","firstNonNullRow","find","row","firstKey","Object","keys","rawValues","filter","rawValue","sqlValuesAlias","Symbol","convertFieldBack","value","literal","namespaceName","name","filteredValuesResults","length","finalRows","__isNull","shift"],"mappings":"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","file":"viaTemporaryTable.js","sourcesContent":["// @flow\n\nimport * as sql from \"pg-sql2\";\nimport type { Client } from \"pg\";\nimport type { SQL, SQLQuery } from \"pg-sql2\";\nimport debugSql from \"./debugSql\";\n\n/*\n * Originally we tried this with a CTE, but:\n *\n * > The sub-statements in WITH are executed concurrently with each other and\n * > with the main query. Therefore, when using data-modifying statements in\n * > WITH, the order in which the specified updates actually happen is\n * > unpredictable. All the statements are executed with the same snapshot (see\n * > Chapter 13), so they cannot \"see\" one another's effects on the target\n * > tables. This alleviates the effects of the unpredictability of the actual\n * > order of row updates, and means that RETURNING data is the only way to\n * > communicate changes between different WITH sub-statements and the main\n * > query.\n *\n * -- https://www.postgresql.org/docs/9.6/static/queries-with.html\n *\n * This caused issues with computed columns that themselves went off and\n * performed selects - because the data within those selects used the old\n * snapshot and thus returned stale data.\n *\n * To solve this, we tried using temporary tables to ensure the mutation and\n * the select execute in different statments. This worked, but temporary tables\n * require elevated priviliges and thus don't work everywhere. We needed a more\n * generic solution.\n *\n * In the end we settled for sending the data we received from the mutations\n * straight back into the PostgreSQL server. It's a bit wasteful but it works.\n *\n * If you can come up with a better solution please open a pull request!\n */\n\nexport default async function viaTemporaryTable(\n  pgClient: Client,\n  sqlTypeIdentifier: ?SQL,\n  sqlMutationQuery: SQL,\n  sqlResultSourceAlias: SQL,\n  sqlResultQuery: SQL,\n  isPgClassLike: boolean = true,\n  pgRecordInfo: ?{\n    // eslint-disable-next-line flowtype/no-weak-types\n    outputArgTypes: Array<any>,\n    outputArgNames: Array<string>,\n  } = undefined\n) {\n  const isPgRecord = pgRecordInfo != null;\n  const { outputArgTypes, outputArgNames } = pgRecordInfo || {};\n\n  async function performQuery(pgClient: Client, sqlQuery: SQLQuery) {\n    // TODO: look into rowMode = 'array'\n    const { text, values } = sql.compile(sqlQuery);\n    if (debugSql.enabled) debugSql(text);\n    return pgClient.query(text, values);\n  }\n\n  if (!sqlTypeIdentifier) {\n    // It returns void, just perform the query!\n    const { rows } = await performQuery(\n      pgClient,\n      sql.query`\n      with ${sqlResultSourceAlias} as (\n        ${sqlMutationQuery}\n      ) ${sqlResultQuery}`\n    );\n    return rows;\n  } else {\n    /*\n     * In this code we're converting the rows to a string representation within\n     * PostgreSQL itself, then we can send it back into PostgreSQL and have it\n     * re-interpret the results cleanly (using it's own serializer/parser\n     * combination) so we should be fairly confident that it will work\n     * correctly every time assuming none of the PostgreSQL types are broken.\n     *\n     * If you have a way to improve this, I'd love to see a PR - but please\n     * make sure that the integration tests pass with your solution first as\n     * there are a log of potential pitfalls!\n     */\n    const selectionField = isPgClassLike\n      ? /*\n         * This `when foo is null then null` check might *seem* redundant, but it\n         * is not - e.g. the compound type `(,,,,,,,)::my_type` and\n         * `null::my_type` differ; however the former also returns true to `foo\n         * is null`. We use this check to coalesce both into the canonical `null`\n         * representation to make it easier to deal with below.\n         */\n        sql.query`(case when ${sqlResultSourceAlias} is null then null else ${sqlResultSourceAlias} end)`\n      : isPgRecord\n        ? sql.query`array[${sql.join(\n            outputArgNames.map(\n              (outputArgName, idx) =>\n                sql.query`${sqlResultSourceAlias}.${sql.identifier(\n                  // According to https://www.postgresql.org/docs/10/static/sql-createfunction.html,\n                  // \"If you omit the name for an output argument, the system will choose a default column name.\"\n                  // In PG 9.x and 10, the column names appear to be assigned with a `column` prefix.\n                  outputArgName !== \"\" ? outputArgName : `column${idx + 1}`\n                )}::text`\n            ),\n            \" ,\"\n          )}]`\n        : sql.query`(${sqlResultSourceAlias}.${sqlResultSourceAlias})::${sqlTypeIdentifier}`;\n    const result = await performQuery(\n      pgClient,\n      sql.query`\n      with ${sqlResultSourceAlias} as (\n        ${sqlMutationQuery}\n      )\n      select (${selectionField})::text from ${sqlResultSourceAlias}`\n    );\n    const { rows } = result;\n    const firstNonNullRow = rows.find(row => row !== null);\n    // TODO: we should be able to have `pg` not interpret the results as\n    // objects and instead just return them as arrays - then we can just do\n    // `row[0]`. PR welcome!\n    const firstKey = firstNonNullRow && Object.keys(firstNonNullRow)[0];\n    const rawValues = rows.map(row => row && row[firstKey]);\n    const values = rawValues.filter(rawValue => rawValue !== null);\n    const sqlValuesAlias = sql.identifier(Symbol());\n    const convertFieldBack = isPgClassLike\n      ? sql.query`\\\n              select (str::${sqlTypeIdentifier}).*\n              from unnest((${sql.value(values)})::text[]) str`\n      : isPgRecord\n        ? sql.query`\\\n          select ${sql.join(\n            outputArgNames.map(\n              (outputArgName, idx) =>\n                sql.query`\\\n                    (${sqlValuesAlias}.output_value_list)[${sql.literal(\n                  idx + 1\n                )}]::${sql.identifier(\n                  outputArgTypes[idx].namespaceName,\n                  outputArgTypes[idx].name\n                )} as ${sql.identifier(\n                  // According to https://www.postgresql.org/docs/10/static/sql-createfunction.html,\n                  // \"If you omit the name for an output argument, the system will choose a default column name.\"\n                  // In PG 9.x and 10, the column names appear to be assigned with a `column` prefix.\n                  outputArgName !== \"\" ? outputArgName : `column${idx + 1}`\n                )}`\n            ),\n            \", \"\n          )}\n          from (values ${sql.join(\n            values.map(value => sql.query`(${sql.value(value)}::text[])`),\n            \", \"\n          )}) as ${sqlValuesAlias}(output_value_list)`\n        : sql.query`\\\n        select str::${sqlTypeIdentifier} as ${sqlResultSourceAlias}\n        from unnest((${sql.value(values)})::text[]) str`;\n    const { rows: filteredValuesResults } =\n      values.length > 0\n        ? await performQuery(\n            pgClient,\n            sql.query`\\\n              with ${sqlResultSourceAlias} as (\n                ${convertFieldBack}\n              )\n              ${sqlResultQuery}\n              `\n          )\n        : { rows: [] };\n    const finalRows = rawValues.map(\n      rawValue =>\n        /*\n         * We can't simply return 'null' here because this is expected to have\n         * come from PG, and that would never return 'null' for a row - only\n         * the fields within said row. Using `__isNull` here is a simple\n         * workaround to this, that's caught by `pg2gql`.\n         */\n        rawValue === null ? { __isNull: true } : filteredValuesResults.shift()\n    );\n    return finalRows;\n  }\n}\n"]}