{"version":3,"sources":["../../src/plugins/PgConditionComputedColumnPlugin.js"],"names":["getCompatibleComputedColumns","build","table","pgIntrospectionResultsByKind","introspectionResultsByKind","pgOmit","omit","procedure","reduce","memo","proc","tags","filterable","computedColumnDetails","pseudoColumnName","nonOptionalArgumentsCount","argDefaultsNum","inputArgsCount","returnsSet","returnType","typeById","returnTypeId","isPgArray","returnTypeTable","classById","classId","isRecordLike","id","isVoid","String","push","PgConditionComputedColumnPlugin","builder","hook","fields","context","extend","pgGetGqlInputTypeByTypeIdAndModifier","inflection","describePgEntity","scope","isPgCondition","pgIntrospection","fieldWithHooks","kind","compatibleComputedColumns","fieldName","computedColumn","Type","description","type","isPgConnectionConditionInputField","pgFieldIntrospection","args","pgSql","sql","gql2pg","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","graphql","getNullableType","isPgFieldConnection","isPgFieldSimpleCollection","pgFieldIntrospectionTable","addArgDataGenerator","shouldAddCondition","condition","namespace","TableType","TableConditionType","conditionType","name","map","o","sqlFnName","identifier","namespaceName","connectionCondition","pgQuery","queryBuilder","forEach","val","sqlCall","fragment","getTableAlias","where"],"mappings":"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","file":"PgConditionComputedColumnPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport { getComputedColumnDetails } from \"./PgComputedColumnsPlugin\";\nimport assert from \"assert\";\nfunction getCompatibleComputedColumns(build, table) {\n  const {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgOmit: omit,\n  } = build;\n  return introspectionResultsByKind.procedure.reduce((memo, proc) => {\n    /* ALSO SEE PgOrderComputedColumnsPlugin */\n    // Must be marked @filterable\n    if (!proc.tags.filterable) return memo;\n\n    // Must not be omitted\n    if (omit(proc, \"execute\")) return memo;\n\n    // Must be a computed column\n    const computedColumnDetails = getComputedColumnDetails(build, table, proc);\n    if (!computedColumnDetails) return memo;\n    const { pseudoColumnName } = computedColumnDetails;\n\n    // Must have only one required argument\n    const nonOptionalArgumentsCount = proc.argDefaultsNum - proc.inputArgsCount;\n    if (nonOptionalArgumentsCount > 1) {\n      return memo;\n    }\n\n    // Must return a scalar\n    if (proc.returnsSet) return memo;\n    const returnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n    if (returnType.isPgArray) return memo;\n    const returnTypeTable =\n      introspectionResultsByKind.classById[returnType.classId];\n    if (returnTypeTable) return memo;\n    const isRecordLike = returnType.id === \"2249\";\n    if (isRecordLike) return memo;\n    const isVoid = String(returnType.id) === \"2278\";\n    if (isVoid) return memo;\n\n    // Looks good\n    memo.push({ proc, pseudoColumnName, returnType });\n    return memo;\n  }, []);\n}\n\nexport default (function PgConditionComputedColumnPlugin(builder) {\n  builder.hook(\"GraphQLInputObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      inflection,\n      describePgEntity,\n    } = build;\n    const {\n      scope: { isPgCondition, pgIntrospection: table },\n      fieldWithHooks,\n    } = context;\n    if (!isPgCondition || !table || table.kind !== \"class\") {\n      return fields;\n    }\n    const compatibleComputedColumns = getCompatibleComputedColumns(\n      build,\n      table\n    );\n    return extend(\n      fields,\n      compatibleComputedColumns.reduce((memo, { proc, pseudoColumnName }) => {\n        const fieldName = inflection.computedColumn(\n          pseudoColumnName,\n          proc,\n          table\n        );\n        const Type = pgGetGqlInputTypeByTypeIdAndModifier(\n          proc.returnTypeId,\n          null\n        );\n        if (!Type) return memo;\n        memo = build.extend(\n          memo,\n          {\n            [fieldName]: fieldWithHooks(\n              fieldName,\n              {\n                description: `Checks for equality with the objectâ€™s \\`${fieldName}\\` field.`,\n                type: Type,\n              },\n              {\n                isPgConnectionConditionInputField: true,\n                pgFieldIntrospection: proc,\n              }\n            ),\n          },\n          `Adding computed column condition argument for ${describePgEntity(\n            proc\n          )}`\n        );\n        return memo;\n      }, {})\n    );\n  });\n\n  builder.hook(\n    \"GraphQLObjectType:fields:field:args\",\n    (args, build, context) => {\n      const {\n        pgSql: sql,\n        gql2pg,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        inflection,\n        pgOmit: omit,\n        graphql: { getNullableType },\n      } = build;\n      const {\n        scope: {\n          isPgFieldConnection,\n          isPgFieldSimpleCollection,\n          pgFieldIntrospection,\n          pgFieldIntrospectionTable,\n        },\n        addArgDataGenerator,\n      } = context;\n\n      const shouldAddCondition =\n        isPgFieldConnection || isPgFieldSimpleCollection;\n      if (!shouldAddCondition) return args;\n      if (!args.condition) {\n        return args;\n      }\n      const proc =\n        pgFieldIntrospection.kind === \"procedure\" ? pgFieldIntrospection : null;\n      const table =\n        pgFieldIntrospection.kind === \"class\"\n          ? pgFieldIntrospection\n          : proc\n            ? pgFieldIntrospectionTable\n            : null;\n      if (\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace ||\n        omit(table, \"filter\")\n      ) {\n        return args;\n      }\n      const TableType = pgGetGqlTypeByTypeIdAndModifier(table.type.id, null);\n      const TableConditionType = getTypeByName(\n        inflection.conditionType(TableType.name)\n      );\n      if (!TableConditionType) {\n        return args;\n      }\n      assert(\n        getNullableType(args.condition.type) === TableConditionType,\n        \"Condition is present, but doesn't match?\"\n      );\n\n      const compatibleComputedColumns = getCompatibleComputedColumns(\n        build,\n        table\n      ).map(o => {\n        const { proc, pseudoColumnName } = o;\n\n        const fieldName = inflection.computedColumn(\n          pseudoColumnName,\n          proc,\n          table\n        );\n        const sqlFnName = sql.identifier(proc.namespaceName, proc.name);\n        return {\n          ...o,\n          fieldName,\n          sqlFnName,\n        };\n      });\n      addArgDataGenerator(function connectionCondition({ condition }) {\n        return {\n          pgQuery: queryBuilder => {\n            if (condition != null) {\n              compatibleComputedColumns.forEach(\n                ({ fieldName, sqlFnName, returnType }) => {\n                  const val = condition[fieldName];\n                  const sqlCall = sql.fragment`${sqlFnName}(${queryBuilder.getTableAlias()})`;\n                  if (val != null) {\n                    queryBuilder.where(\n                      sql.fragment`${sqlCall} = ${gql2pg(\n                        val,\n                        returnType,\n                        null\n                      )}`\n                    );\n                  } else if (val === null) {\n                    queryBuilder.where(sql.fragment`${sqlCall} IS NULL`);\n                  }\n                }\n              );\n            }\n          },\n        };\n      });\n\n      return args;\n    }\n  );\n}: Plugin);\n"]}