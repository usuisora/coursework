{"version":3,"sources":["../../src/plugins/PgRecordFunctionConnectionPlugin.js"],"names":["base64","str","Buffer","from","String","toString","PgRecordFunctionConnectionPlugin","builder","pgForbidSetofFunctionsToReturnNull","hook","_","build","newWithHooks","getSafeAliasFromResolveInfo","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLList","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","procedure","forEach","proc","returnsSet","namespace","returnTypeId","NodeType","recordFunctionReturnType","Error","name","EdgeType","recordFunctionEdge","description","fields","fieldWithHooks","cursor","addDataGenerator","usesCursor","type","resolve","data","JSON","stringify","__cursor","isCursorField","node","_args","_context","resolveInfo","safeAlias","__origin","isEdgeType","nodeType","pgIntrospection","recordFunctionConnection","nodes","map","entry","edges","hoistCursor","isConnectionType","edgeType"],"mappings":"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","file":"PgRecordFunctionConnectionPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nexport default (function PgRecordFunctionConnectionPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false }\n) {\n  builder.hook(\"init\", (_, build) => {\n    const {\n      newWithHooks,\n      getSafeAliasFromResolveInfo,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      getTypeByName,\n      graphql: { GraphQLObjectType, GraphQLNonNull, GraphQLList },\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n      pgField,\n    } = build;\n\n    const nullableIf = (condition, Type) =>\n      condition ? Type : new GraphQLNonNull(Type);\n    const Cursor = getTypeByName(\"Cursor\");\n\n    introspectionResultsByKind.procedure.forEach(proc => {\n      // PERFORMANCE: These used to be .filter(...) calls\n      if (!proc.returnsSet) return;\n      if (!proc.namespace) return;\n      if (omit(proc, \"execute\")) return;\n\n      if (proc.returnTypeId !== \"2249\") {\n        // Does not return a record type; defer handling to\n        // PgTablesPlugin and PgScalarFunctionConnectionPlugin\n        return;\n      }\n      // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod\n      // on function arguments and return types, however maybe a later\n      // version of PG will?\n      const NodeType = getTypeByName(inflection.recordFunctionReturnType(proc));\n      if (!NodeType) {\n        throw new Error(\n          `Do not have a node type '${inflection.recordFunctionReturnType(\n            proc\n          )}' for '${proc.name}' so cannot create connection type`\n        );\n      }\n      const EdgeType = newWithHooks(\n        GraphQLObjectType,\n        {\n          name: inflection.recordFunctionEdge(proc),\n          description: `A \\`${NodeType.name}\\` edge in the connection.`,\n          fields: ({ fieldWithHooks }) => {\n            return {\n              cursor: fieldWithHooks(\n                \"cursor\",\n                ({ addDataGenerator }) => {\n                  addDataGenerator(() => ({\n                    usesCursor: [true],\n                  }));\n                  return {\n                    description: \"A cursor for use in pagination.\",\n                    type: Cursor,\n                    resolve(data) {\n                      return base64(JSON.stringify(data.__cursor));\n                    },\n                  };\n                },\n                {\n                  isCursorField: true,\n                }\n              ),\n              node: pgField(\n                build,\n                fieldWithHooks,\n                \"node\",\n                {\n                  description: `The \\`${\n                    NodeType.name\n                  }\\` at the end of the edge.`,\n                  type: nullableIf(\n                    !pgForbidSetofFunctionsToReturnNull,\n                    NodeType\n                  ),\n                  resolve(data, _args, _context, resolveInfo) {\n                    const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n                    return data[safeAlias];\n                  },\n                },\n                {},\n                false\n              ),\n            };\n          },\n        },\n        {\n          __origin: `Adding function result edge type for ${describePgEntity(\n            proc\n          )}. You can rename the function's GraphQL field (and its dependent types) via:\\n\\n  ${sqlCommentByAddingTags(\n            proc,\n            {\n              name: \"newNameHere\",\n            }\n          )}`,\n          isEdgeType: true,\n          nodeType: NodeType,\n          pgIntrospection: proc,\n        }\n      );\n\n      /*const ConnectionType = */\n      newWithHooks(\n        GraphQLObjectType,\n        {\n          name: inflection.recordFunctionConnection(proc),\n          description: `A connection to a list of \\`${NodeType.name}\\` values.`,\n          fields: ({ fieldWithHooks }) => {\n            return {\n              nodes: pgField(build, fieldWithHooks, \"nodes\", {\n                description: `A list of \\`${NodeType.name}\\` objects.`,\n                type: new GraphQLNonNull(\n                  new GraphQLList(\n                    nullableIf(!pgForbidSetofFunctionsToReturnNull, NodeType)\n                  )\n                ),\n                resolve(data, _args, _context, resolveInfo) {\n                  const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n                  return data.data.map(entry => entry[safeAlias]);\n                },\n              }),\n              edges: pgField(\n                build,\n                fieldWithHooks,\n                \"edges\",\n                {\n                  description: `A list of edges which contains the \\`${\n                    NodeType.name\n                  }\\` and cursor to aid in pagination.`,\n                  type: new GraphQLNonNull(\n                    new GraphQLList(new GraphQLNonNull(EdgeType))\n                  ),\n                  resolve(data, _args, _context, resolveInfo) {\n                    const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n                    return data.data.map(entry => ({\n                      __cursor: entry.__cursor,\n                      ...entry[safeAlias],\n                    }));\n                  },\n                },\n                {},\n                false,\n                {\n                  hoistCursor: true,\n                }\n              ),\n            };\n          },\n        },\n        {\n          __origin: `Adding function connection type for ${describePgEntity(\n            proc\n          )}. You can rename the function's GraphQL field (and its dependent types) via:\\n\\n  ${sqlCommentByAddingTags(\n            proc,\n            {\n              name: \"newNameHere\",\n            }\n          )}`,\n          isConnectionType: true,\n          edgeType: EdgeType,\n          nodeType: NodeType,\n          pgIntrospection: proc,\n        }\n      );\n    });\n    return _;\n  });\n}: Plugin);\n"]}