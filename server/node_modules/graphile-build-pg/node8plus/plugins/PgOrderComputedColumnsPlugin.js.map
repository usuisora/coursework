{"version":3,"sources":["../../src/plugins/PgOrderComputedColumnsPlugin.js"],"names":["PgOrderComputedColumnsPlugin","builder","hook","values","build","context","extend","inflection","pgOmit","omit","describePgEntity","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","scope","isPgRowSortEnum","pgIntrospection","table","kind","compatibleComputedColumns","procedure","reduce","memo","proc","tags","sortable","computedColumnDetails","pseudoColumnName","nonOptionalArgumentsCount","argDefaultsNum","inputArgsCount","returnsSet","returnType","typeById","returnTypeId","isPgArray","returnTypeTable","classById","classId","isRecordLike","id","isVoid","String","push","ascFieldName","orderByComputedColumnEnum","descFieldName","unique","isUnique","functionCall","queryBuilder","fragment","identifier","namespaceName","name","getTableAlias","value","alias","toLowerCase","specs"],"mappings":"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","file":"PgOrderComputedColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport { getComputedColumnDetails } from \"./PgComputedColumnsPlugin\";\n\nexport default (function PgOrderComputedColumnsPlugin(builder) {\n  builder.hook(\"GraphQLEnumType:values\", (values, build, context) => {\n    const {\n      extend,\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n    } = build;\n    const {\n      scope: { isPgRowSortEnum, pgIntrospection: table },\n    } = context;\n    if (!isPgRowSortEnum || !table || table.kind !== \"class\") {\n      return values;\n    }\n\n    const compatibleComputedColumns = introspectionResultsByKind.procedure.reduce(\n      (memo, proc) => {\n        /* ALSO SEE PgConditionComputedColumnPlugin */\n        // Must be marked @sortable\n        if (!proc.tags.sortable) return memo;\n\n        // Must not be omitted\n        if (omit(proc, \"execute\")) return memo;\n\n        // Must be a computed column\n        const computedColumnDetails = getComputedColumnDetails(\n          build,\n          table,\n          proc\n        );\n        if (!computedColumnDetails) return memo;\n        const { pseudoColumnName } = computedColumnDetails;\n\n        // Must have only one required argument\n        const nonOptionalArgumentsCount =\n          proc.argDefaultsNum - proc.inputArgsCount;\n        if (nonOptionalArgumentsCount > 1) {\n          return memo;\n        }\n\n        // Must return a scalar\n        if (proc.returnsSet) return memo;\n        const returnType =\n          introspectionResultsByKind.typeById[proc.returnTypeId];\n        if (returnType.isPgArray) return memo;\n        const returnTypeTable =\n          introspectionResultsByKind.classById[returnType.classId];\n        if (returnTypeTable) return memo;\n        const isRecordLike = returnType.id === \"2249\";\n        if (isRecordLike) return memo;\n        const isVoid = String(returnType.id) === \"2278\";\n        if (isVoid) return memo;\n\n        // Looks good\n        memo.push({ proc, pseudoColumnName });\n        return memo;\n      },\n      []\n    );\n    return extend(\n      values,\n      compatibleComputedColumns.reduce((memo, { proc, pseudoColumnName }) => {\n        const ascFieldName = inflection.orderByComputedColumnEnum(\n          pseudoColumnName,\n          proc,\n          table,\n          true\n        );\n        const descFieldName = inflection.orderByComputedColumnEnum(\n          pseudoColumnName,\n          proc,\n          table,\n          false\n        );\n\n        const unique = !!proc.tags.isUnique;\n\n        const functionCall = ({ queryBuilder }) =>\n          sql.fragment`(${sql.identifier(\n            proc.namespaceName,\n            proc.name\n          )}(${queryBuilder.getTableAlias()}))`;\n\n        memo = extend(\n          memo,\n          {\n            [ascFieldName]: {\n              value: {\n                alias: ascFieldName.toLowerCase(),\n                specs: [[functionCall, true]],\n                unique,\n              },\n            },\n          },\n          `Adding ascending orderBy enum value for ${describePgEntity(\n            proc\n          )}. You can rename this field by removing the '@sortable' smart comment from the function.`\n        );\n        memo = extend(\n          memo,\n          {\n            [descFieldName]: {\n              value: {\n                alias: descFieldName.toLowerCase(),\n                specs: [[functionCall, false]],\n                unique,\n              },\n            },\n          },\n          `Adding descending orderBy enum value for ${describePgEntity(\n            proc\n          )}. You can rename this field by removing the '@sortable' smart comment from the function.`\n        );\n        return memo;\n      }, {}),\n      `Adding order values from table '${table.name}'`\n    );\n  });\n}: Plugin);\n"]}