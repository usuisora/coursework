{"version":3,"sources":["../../src/plugins/PgColumnsPlugin.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","PgColumnsPlugin","builder","hook","build","pgSql","sql","pgTweakFragmentForTypeAndModifier","pgQueryFromResolveData","queryFromResolveData","getSelectValueForFieldAndTypeAndModifier","ReturnType","fieldScope","parsedResolveInfoFragment","sqlFullName","type","typeModifier","getDataFromParsedResolveInfoFragment","isPgArray","ident","identifier","Symbol","fragment","arrayItemType","resolveData","jsonBuildObject","onlyJsonField","addNullCase","extend","pgGetSelectValueForFieldAndTypeAndModifier","fields","context","pgGetGqlTypeByTypeIdAndModifier","pg2gql","graphql","GraphQLString","pgColumnFilter","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","scope","isPgRowType","isPgCompoundType","pgIntrospection","table","fieldWithHooks","kind","attributes","reduce","memo","attr","fieldName","column","Error","namespaceName","name","fieldContext","addDataGenerator","typeId","pgQuery","queryBuilder","select","getTableAlias","description","isNotNull","domainIsNotNull","tags","notNull","resolve","data","_args","_context","_resolveInfo","pgFieldIntrospection","pgGetGqlInputTypeByTypeIdAndModifier","isPgPatch","isPgBaseInput","pgAddSubfield","action","identity","hasDefault"],"mappings":"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","file":"PgColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nexport default (function PgColumnsPlugin(builder) {\n  builder.hook(\"build\", build => {\n    const {\n      pgSql: sql,\n      pgTweakFragmentForTypeAndModifier,\n      pgQueryFromResolveData: queryFromResolveData,\n    } = build;\n    const getSelectValueForFieldAndTypeAndModifier = (\n      ReturnType,\n      fieldScope,\n      parsedResolveInfoFragment,\n      sqlFullName,\n      type,\n      typeModifier\n    ) => {\n      const { getDataFromParsedResolveInfoFragment } = fieldScope;\n      if (type.isPgArray) {\n        const ident = sql.identifier(Symbol());\n        return sql.fragment`\n          (\n            case\n            when ${sqlFullName} is null then null\n            when coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json\n            else\n              (\n                select json_agg(${getSelectValueForFieldAndTypeAndModifier(\n                  ReturnType,\n                  fieldScope,\n                  parsedResolveInfoFragment,\n                  ident,\n                  type.arrayItemType,\n                  typeModifier\n                )})\n                from unnest(${sqlFullName}) as ${ident}\n              )\n            end\n          )\n        `;\n      } else {\n        const resolveData = getDataFromParsedResolveInfoFragment(\n          parsedResolveInfoFragment,\n          ReturnType\n        );\n        if (type.type === \"c\") {\n          const jsonBuildObject = queryFromResolveData(\n            sql.identifier(Symbol()), // Ignore!\n            sqlFullName,\n            resolveData,\n            { onlyJsonField: true, addNullCase: true }\n          );\n          return jsonBuildObject;\n        } else {\n          return pgTweakFragmentForTypeAndModifier(\n            sqlFullName,\n            type,\n            typeModifier,\n            resolveData\n          );\n        }\n      }\n    };\n    return build.extend(build, {\n      pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n    });\n  });\n\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgSql: sql,\n      pg2gql,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgColumnFilter,\n      inflection,\n      pgOmit: omit,\n      pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const {\n      scope: { isPgRowType, isPgCompoundType, pgIntrospection: table },\n      fieldWithHooks,\n    } = context;\n\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n\n    return extend(\n      fields,\n      table.attributes.reduce((memo, attr) => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!pgColumnFilter(attr, build, context)) return memo;\n        if (omit(attr, \"read\")) return memo;\n\n        const fieldName = inflection.column(attr);\n        if (memo[fieldName]) {\n          throw new Error(\n            `Two columns produce the same GraphQL field name '${fieldName}' on class '${\n              table.namespaceName\n            }.${table.name}'; one of them is '${attr.name}'`\n          );\n        }\n        memo = extend(\n          memo,\n          {\n            [fieldName]: fieldWithHooks(\n              fieldName,\n              fieldContext => {\n                const { addDataGenerator } = fieldContext;\n                const ReturnType =\n                  pgGetGqlTypeByTypeIdAndModifier(\n                    attr.typeId,\n                    attr.typeModifier\n                  ) || GraphQLString;\n                addDataGenerator(parsedResolveInfoFragment => {\n                  return {\n                    pgQuery: queryBuilder => {\n                      queryBuilder.select(\n                        getSelectValueForFieldAndTypeAndModifier(\n                          ReturnType,\n                          fieldContext,\n                          parsedResolveInfoFragment,\n                          sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(\n                            attr.name\n                          )})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING\n                          attr.type,\n                          attr.typeModifier\n                        ),\n                        fieldName\n                      );\n                    },\n                  };\n                });\n                return {\n                  description: attr.description,\n                  type: nullableIf(\n                    GraphQLNonNull,\n                    !attr.isNotNull &&\n                      !attr.type.domainIsNotNull &&\n                      !attr.tags.notNull,\n                    ReturnType\n                  ),\n                  resolve: (data, _args, _context, _resolveInfo) => {\n                    return pg2gql(data[fieldName], attr.type);\n                  },\n                };\n              },\n              { pgFieldIntrospection: attr }\n            ),\n          },\n          `Adding field for ${describePgEntity(\n            attr\n          )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n            attr,\n            {\n              name: \"newNameHere\",\n            }\n          )}`\n        );\n        return memo;\n      }, {}),\n      `Adding columns to '${describePgEntity(table)}'`\n    );\n  });\n  builder.hook(\"GraphQLInputObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgColumnFilter,\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isPgPatch,\n        isPgBaseInput,\n        pgIntrospection: table,\n        pgAddSubfield,\n      },\n      fieldWithHooks,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      table.attributes.reduce((memo, attr) => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!pgColumnFilter(attr, build, context)) return memo;\n        const action = isPgBaseInput ? \"base\" : isPgPatch ? \"update\" : \"create\";\n        if (omit(attr, action)) return memo;\n        if (attr.identity === \"a\") return memo;\n\n        const fieldName = inflection.column(attr);\n        if (memo[fieldName]) {\n          throw new Error(\n            `Two columns produce the same GraphQL field name '${fieldName}' on input class '${\n              table.namespaceName\n            }.${table.name}'; one of them is '${attr.name}'`\n          );\n        }\n        memo = extend(\n          memo,\n          {\n            [fieldName]: fieldWithHooks(\n              fieldName,\n              pgAddSubfield(\n                fieldName,\n                attr.name,\n                attr.type,\n                {\n                  description: attr.description,\n                  type: nullableIf(\n                    GraphQLNonNull,\n                    isPgBaseInput ||\n                      isPgPatch ||\n                      (!attr.isNotNull &&\n                        !attr.type.domainIsNotNull &&\n                        !attr.tags.notNull) ||\n                      attr.hasDefault ||\n                      attr.identity === \"d\",\n                    pgGetGqlInputTypeByTypeIdAndModifier(\n                      attr.typeId,\n                      attr.typeModifier\n                    ) || GraphQLString\n                  ),\n                },\n                attr.typeModifier\n              ),\n              { pgFieldIntrospection: attr }\n            ),\n          },\n          `Adding input object field for ${describePgEntity(\n            attr\n          )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n            attr,\n            {\n              name: \"newNameHere\",\n            }\n          )}`\n        );\n        return memo;\n      }, {}),\n      `Adding columns to input object for ${describePgEntity(table)}`\n    );\n  });\n}: Plugin);\n"]}